---
source-updated-at: '2025-05-08T02:24:20.000Z'
translation-updated-at: '2025-05-08T06:02:10.702Z'
title: Руководство по троттлингу
id: throttling
---
# Руководство по троттлингу (Throttling Guide)

Ограничение частоты (Rate Limiting), троттлинг (Throttling) и дебаунсинг (Debouncing) — это три различных подхода к контролю частоты выполнения функций. Каждый метод по-своему блокирует выполнение, делая их "потерянными" (lossy) — это означает, что некоторые вызовы функций не будут выполнены, если они запрашиваются слишком часто. Понимание, когда использовать каждый подход, крайне важно для создания производительных и надежных приложений. В этом руководстве рассматриваются концепции троттлинга в TanStack Pacer.

## Концепция троттлинга (Throttling Concept)

Троттлинг гарантирует, что выполнение функций равномерно распределено во времени. В отличие от ограничения частоты (rate limiting), которое допускает всплески выполнения до определенного предела, или дебаунсинга (debouncing), который ждет остановки активности, троттлинг создает более плавный паттерн выполнения, обеспечивая постоянные задержки между вызовами. Если вы установите троттлинг на одно выполнение в секунду, вызовы будут равномерно распределены, независимо от того, как часто они запрашиваются.

### Визуализация троттлинга (Throttling Visualization)

```text
Throttling (one execution per 3 ticks)
Timeline: [1 second per tick]
Calls:        ⬇️  ⬇️  ⬇️           ⬇️  ⬇️  ⬇️  ⬇️             ⬇️
Executed:     ✅  ❌  ⏳  ->   ✅  ❌  ❌  ❌  ✅             ✅ 
             [=================================================================]
             ^ Only one execution allowed per 3 ticks,
               regardless of how many calls are made

             [First burst]    [More calls]              [Spaced calls]
             Execute first    Execute after             Execute each time
             then throttle    wait period               wait period passes
```

### Когда использовать троттлинг (When to Use Throttling)

Троттлинг особенно эффективен, когда вам нужно последовательное, предсказуемое время выполнения. Это делает его идеальным для обработки частых событий или обновлений, где требуется плавное, контролируемое поведение.

Распространенные сценарии использования:
- Обновления пользовательского интерфейса (UI updates), требующие стабильного времени (например, индикаторы прогресса)
- Обработчики событий прокрутки (scroll) или изменения размера (resize), которые не должны перегружать браузер
- Опрос данных в реальном времени (real-time data polling), где требуются постоянные интервалы
- Ресурсоемкие операции (resource-intensive operations), требующие равномерного темпа
- Обновления игрового цикла (game loop updates) или обработка кадров анимации (animation frame handling)
- Подсказки при поиске в реальном времени (live search suggestions) по мере ввода пользователем

### Когда не использовать троттлинг (When Not to Use Throttling)

Троттлинг может быть не лучшим выбором, когда:
- Вы хотите дождаться остановки активности (вместо этого используйте [дебаунсинг](../guides/debouncing))
- Вы не можете позволить себе пропустить ни одного выполнения (вместо этого используйте [очередь (queueing)](../guides/queueing))

> [!TIP]
> Троттлинг часто является лучшим выбором, когда вам нужно плавное, последовательное время выполнения. Он обеспечивает более предсказуемый паттерн выполнения, чем ограничение частоты (rate limiting), и более быструю обратную связь, чем дебаунсинг (debouncing).

## Троттлинг в TanStack Pacer (Throttling in TanStack Pacer)

TanStack Pacer предоставляет как синхронный, так и асинхронный троттлинг через классы `Throttler` и `AsyncThrottler` соответственно (и соответствующие функции `throttle` и `asyncThrottle`).

### Базовое использование с `throttle` (Basic Usage with `throttle`)

Функция `throttle` — это самый простой способ добавить троттлинг к любой функции:

```ts
import { throttle } from '@tanstack/pacer'

// Троттлинг обновлений UI до одного каждые 200 мс
const throttledUpdate = throttle(
  (value: number) => updateProgressBar(value),
  {
    wait: 200,
  }
)

// В быстром цикле выполняется только каждые 200 мс
for (let i = 0; i < 100; i++) {
  throttledUpdate(i) // Многие вызовы подвергаются троттлингу
}
```

### Расширенное использование с классом `Throttler` (Advanced Usage with `Throttler` Class)

Для большего контроля над поведением троттлинга можно напрямую использовать класс `Throttler`:

```ts
import { Throttler } from '@tanstack/pacer'

const updateThrottler = new Throttler(
  (value: number) => updateProgressBar(value),
  { wait: 200 }
)

// Получение информации о состоянии выполнения
console.log(updateThrottler.getExecutionCount()) // Количество успешных выполнений
console.log(updateThrottler.getLastExecutionTime()) // Время последнего выполнения

// Отмена любого ожидающего выполнения
updateThrottler.cancel()
```

### Первое и последующее выполнение (Leading and Trailing Executions)

Синхронный троттлер поддерживает выполнение как на переднем (leading), так и на заднем (trailing) фронте:

```ts
const throttledFn = throttle(fn, {
  wait: 200,
  leading: true,   // Выполнить при первом вызове (по умолчанию)
  trailing: true,  // Выполнить после периода ожидания (по умолчанию)
})
```

- `leading: true` (по умолчанию) — Выполнить немедленно при первом вызове
- `leading: false` — Пропустить первый вызов, ждать последующего выполнения
- `trailing: true` (по умолчанию) — Выполнить последний вызов после периода ожидания
- `trailing: false` — Пропустить последний вызов, если он в пределах периода ожидания

Распространенные паттерны:
- `{ leading: true, trailing: true }` — По умолчанию, наиболее отзывчивый
- `{ leading: false, trailing: true }` — Задержать все выполнения
- `{ leading: true, trailing: false }` — Пропустить вызовы в очереди

### Включение/отключение (Enabling/Disabling)

Класс `Throttler` поддерживает включение/отключение через опцию `enabled`. Используя метод `setOptions`, вы можете включать/отключать троттлер в любое время:

```ts
const throttler = new Throttler(fn, { wait: 200, enabled: false }) // Отключено по умолчанию
throttler.setOptions({ enabled: true }) // Включить в любое время
```

Если вы используете адаптер для фреймворка, где параметры троттлера реактивны, вы можете установить опцию `enabled` в условное значение для динамического включения/отключения троттлера. Однако, если вы используете функцию `throttle` или класс `Throttler` напрямую, вы должны использовать метод `setOptions` для изменения опции `enabled`, так как переданные параметры фактически передаются в конструктор класса `Throttler`.

### Опции обратного вызова (Callback Options)

Как синхронный, так и асинхронный троттлеры поддерживают опции обратного вызова для обработки различных аспектов жизненного цикла троттлинга:

#### Обратные вызовы синхронного троттлера (Synchronous Throttler Callbacks)

Синхронный `Throttler` поддерживает следующий обратный вызов:

```ts
const throttler = new Throttler(fn, {
  wait: 200,
  onExecute: (throttler) => {
    // Вызывается после каждого успешного выполнения
    console.log('Функция выполнена', throttler.getExecutionCount())
  }
})
```

Обратный вызов `onExecute` вызывается после каждого успешного выполнения троттлированной функции, что делает его полезным для отслеживания выполнений, обновления состояния UI или выполнения операций очистки.

#### Обратные вызовы асинхронного троттлера (Asynchronous Throttler Callbacks)

Асинхронный `AsyncThrottler` поддерживает дополнительные обратные вызовы для обработки ошибок:

```ts
const asyncThrottler = new AsyncThrottler(async (value) => {
  await saveToAPI(value)
}, {
  wait: 200,
  onExecute: (throttler) => {
    // Вызывается после каждого успешного выполнения
    console.log('Асинхронная функция выполнена', throttler.getExecutionCount())
  },
  onError: (error) => {
    // Вызывается, если асинхронная функция выбрасывает ошибку
    console.error('Асинхронная функция завершилась ошибкой:', error)
  }
})
```

Обратный вызов `onExecute` работает так же, как и в синхронном троттлере, а `onError` позволяет обрабатывать ошибки без прерывания цепочки троттлинга. Эти обратные вызовы особенно полезны для отслеживания количества выполнений, обновления состояния UI, обработки ошибок, выполнения операций очистки и логирования метрик выполнения.

### Асинхронный троттлинг (Asynchronous Throttling)

Асинхронный троттлер предоставляет мощный способ обработки асинхронных операций с троттлингом, предлагая несколько ключевых преимуществ по сравнению с синхронной версией. В то время как синхронный троттлер отлично подходит для событий UI и мгновенной обратной связи, асинхронная версия специально разработана для обработки вызовов API, операций с базой данных и других асинхронных задач.

#### Ключевые отличия от синхронного троттлинга (Key Differences from Synchronous Throttling)

1. **Обработка возвращаемого значения (Return Value Handling)**
В отличие от синхронного троттлера, который возвращает `void`, асинхронная версия позволяет захватывать и использовать возвращаемое значение из вашей троттлированной функции. Это особенно полезно, когда вам нужно работать с результатами вызовов API или других асинхронных операций. Метод `maybeExecute` возвращает Promise, который разрешается с возвращаемым значением функции, позволяя вам ожидать результат и обрабатывать его соответствующим образом.

2. **Разные обратные вызовы (Different Callbacks)**
`AsyncThrottler` поддерживает следующие обратные вызовы вместо только `onExecute` в синхронной версии:
- `onSuccess`: Вызывается после каждого успешного выполнения, предоставляя экземпляр троттлера
- `onSettled`: Вызывается после каждого выполнения, предоставляя экземпляр троттлера
- `onError`: Вызывается, если асинхронная функция выбрасывает ошибку, предоставляя как ошибку, так и экземпляр троттлера

Как асинхронный, так и синхронный троттлеры поддерживают обратный вызов `onExecute` для обработки успешных выполнений.

3. **Последовательное выполнение (Sequential Execution)**
Поскольку метод `maybeExecute` троттлера возвращает Promise, вы можете выбрать ожидание каждого выполнения перед началом следующего. Это дает вам контроль над порядком выполнения и гарантирует, что каждый вызов обрабатывает самые актуальные данные. Это особенно полезно при работе с операциями, зависящими от результатов предыдущих вызовов, или когда критически важна согласованность данных.

Например, если вы обновляете профиль пользователя и затем сразу же получаете обновленные данные, вы можете ожидать завершения операции обновления перед началом получения:

#### Базовый пример использования (Basic Usage Example)

Вот базовый пример, показывающий, как использовать асинхронный троттлер для операции поиска:

```ts
const throttledSearch = asyncThrottle(
  async (searchTerm: string) => {
    const results = await fetchSearchResults(searchTerm)
    return results
  },
  {
    wait: 500,
    onSuccess: (results, throttler) => {
      console.log('Поиск выполнен успешно:', results)
    },
    onError: (error, throttler) => {
      console.error('Поиск завершился ошибкой:', error)
    }
  }
)

// Использование
const results = await throttledSearch('query')
```

### Адаптеры для фреймворков (Framework Adapters)

Каждый адаптер для фреймворка предоставляет хуки, которые расширяют базовую функциональность троттлинга для интеграции с системой управления состоянием фреймворка. Для каждого фреймворка доступны хуки, такие как `createThrottler`, `useThrottledCallback`, `useThrottledState` или `useThrottledValue`.

Вот несколько примеров:

#### React

```tsx
import { useThrottler, useThrottledCallback, useThrottledValue } from '@tanstack/react-pacer'

// Низкоуровневый хук для полного контроля
const throttler = useThrottler(
  (value: number) => updateProgressBar(value),
  { wait: 200 }
)

// Простой хук обратного вызова для базовых случаев
const handleUpdate = useThrottledCallback(
  (value: number) => updateProgressBar(value),
  { wait: 200 }
)

// Хук на основе состояния для реактивного управления состоянием
const [instantState, setInstantState] = useState(0)
const [throttledValue] = useThrottledValue(
  instantState, // Значение для троттлинга
  { wait: 200 }
)
```

#### Solid

```tsx
import { createThrottler, createThrottledSignal } from '@tanstack/solid-pacer'

// Низкоуровневый хук для полного контроля
const throttler = createThrottler(
  (value: number) => updateProgressBar(value),
  { wait: 200 }
)

// Хук на основе сигналов для управления состоянием
const [value, setValue, throttler] = createThrottledSignal(0, {
  wait: 200,
  onExecute: (throttler) => {
    console.log('Всего выполнений:', throttler.getExecutionCount())
  }
})
```

Каждый адаптер для фреймворка предоставляет хуки, которые интегрируются с системой управления состоянием фреймворка, сохраняя при этом базовую функциональность троттлинга.
