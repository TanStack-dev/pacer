---
source-updated-at: '2025-04-24T12:27:47.000Z'
translation-updated-at: '2025-05-02T04:37:26.393Z'
title: Руководство по очереди
id: queueing
---
# Руководство по очереди (Queueing)

В отличие от [ограничения скорости (Rate Limiting)](../guides/rate-limiting), [троттлинга (Throttling)](../guides/throttling) и [дебаунсинга (Debouncing)](../guides/debouncing), которые пропускают выполнение при слишком частом вызове, очереди гарантируют обработку каждой операции. Они предоставляют способ управления и контроля потока операций без потери запросов. Это делает их идеальными для сценариев, где потеря данных недопустима. В этом руководстве рассматриваются концепции очередей в TanStack Pacer.

## Концепция очереди (Queueing)

Очередь гарантирует, что каждая операция будет в конечном итоге обработана, даже если они поступают быстрее, чем могут быть выполнены. В отличие от других методов контроля выполнения, которые пропускают избыточные операции, очередь буферизует операции в упорядоченном списке и обрабатывает их согласно определенным правилам. Это делает очередь единственной "безпотерьной" (lossless) техникой контроля выполнения в TanStack Pacer.

### Визуализация очереди (Queueing)

```text
Queueing (processing one item every 2 ticks)
Timeline: [1 second per tick]
Calls:        ⬇️  ⬇️  ⬇️     ⬇️  ⬇️     ⬇️  ⬇️  ⬇️
Queue:       [ABC]   [BC]    [BCDE]    [DE]    [E]    []
Executed:     ✅     ✅       ✅        ✅      ✅     ✅
             [=================================================================]
             ^ В отличие от ограничения скорости/троттлинга/дебаунсинга,
               ВСЕ вызовы в конечном итоге обрабатываются по порядку

             [Элементы накапливаются]   [Обработка по одному]   [Очистка очереди]
              при загруженности         последовательно
```

### Когда использовать очередь (Queueing)

Очередь особенно важна, когда необходимо гарантировать обработку каждой операции, даже если это приведет к некоторой задержке. Это делает ее идеальной для сценариев, где согласованность и полнота данных важнее немедленного выполнения.

Распространенные сценарии использования:
- Обработка пользовательских взаимодействий в интерфейсе, где каждое действие должно быть записано
- Выполнение операций с базой данных, требующих поддержания согласованности данных
- Управление API-запросами, которые должны завершиться успешно
- Координация фоновых задач, которые нельзя пропускать
- Анимационные последовательности, где важен каждый кадр
- Отправка форм, где каждая запись должна быть сохранена

### Когда не использовать очередь (Queueing)

Очередь может быть не лучшим выбором, когда:
- Немедленная обратная связь важнее обработки каждой операции
- Важно только последнее значение (используйте [дебаунсинг](../guides/debouncing))

> [!TIP]
> Если вы используете ограничение скорости, троттлинг или дебаунсинг, но обнаруживаете, что пропущенные операции вызывают проблемы, очередь — вероятное решение.

## Очередь в TanStack Pacer

TanStack Pacer предоставляет функциональность очереди через простую функцию `queue` и более мощный класс `Queuer`. В то время как другие методы контроля выполнения обычно используют API на основе функций, очередь часто выигрывает от дополнительного контроля, предоставляемого API на основе классов.

### Базовое использование с `queue`

Функция `queue` предоставляет простой способ создания постоянно работающей очереди, обрабатывающей элементы по мере их добавления:

```ts
import { queue } from '@tanstack/pacer'

// Создаем очередь, обрабатывающую элементы каждую секунду
const processItems = queue<number>({
  wait: 1000,
  onItemsChange: (queuer) => {
    console.log('Текущая очередь:', queuer.getAllItems())
  }
})

// Добавляем элементы для обработки
processItems(1) // Обрабатывается немедленно
processItems(2) // Обрабатывается через 1 секунду
processItems(3) // Обрабатывается через 2 секунды
```

Хотя функция `queue` проста в использовании, она предоставляет только базовую постоянно работающую очередь через метод `addItem`. Для большинства случаев использования потребуется дополнительный контроль и функции класса `Queuer`.

### Продвинутое использование с классом `Queuer`

Класс `Queuer` предоставляет полный контроль над поведением и обработкой очереди:

```ts
import { Queuer } from '@tanstack/pacer'

// Создаем очередь, обрабатывающую элементы каждую секунду
const queue = new Queuer<number>({
  wait: 1000, // Ожидание 1 секунды между обработкой элементов
  onItemsChange: (queuer) => {
    console.log('Текущая очередь:', queuer.getAllItems())
  }
})

// Начинаем обработку
queue.start()

// Добавляем элементы для обработки
queue.addItem(1)
queue.addItem(2)
queue.addItem(3)

// Элементы будут обрабатываться по одному с задержкой в 1 секунду
// Вывод:
// Обработка: 1 (немедленно)
// Обработка: 2 (через 1 секунду)
// Обработка: 3 (через 2 секунды)
```

### Типы очередей и порядок обработки

Уникальность `Queuer` в TanStack Pacer заключается в его способности адаптироваться к различным сценариям использования через API на основе позиций. Один и тот же `Queuer` может вести себя как традиционная очередь (queue), стек (stack) или двусторонняя очередь (double-ended queue), используя один и тот же интерфейс.

#### FIFO очередь (First In, First Out)

Поведение по умолчанию, при котором элементы обрабатываются в порядке их добавления. Это наиболее распространенный тип очереди, следующий принципу "первым пришел — первым ушел".

```text
Визуализация FIFO очереди:

Добавление →  [A][B][C][D] → Обработка
              ⬇️         ⬆️
           Новые элементы   Элементы
           добавляются здесь обрабатываются здесь

Timeline: [1 second per tick]
Calls:        ⬇️  ⬇️  ⬇️     ⬇️
Queue:       [ABC]   [BC]    [C]    []
Processed:    A       B       C
```

FIFO очереди идеальны для:
- Обработки задач, где важен порядок
- Очередей сообщений, где сообщения должны обрабатываться последовательно
- Очередей печати, где документы должны печататься в порядке отправки
- Систем обработки событий, где события должны обрабатываться в хронологическом порядке

```ts
const queue = new Queuer<number>({
  addItemsTo: 'back', // по умолчанию
  getItemsFrom: 'front', // по умолчанию
})
queue.addItem(1) // [1]
queue.addItem(2) // [1, 2]
// Обрабатывает: 1, затем 2
```

#### LIFO стек (Last In, First Out)

Указав 'back' как позицию для добавления и извлечения элементов, `Queuer` ведет себя как стек. В стеке последний добавленный элемент обрабатывается первым.

```text
Визуализация LIFO стека:

     ⬆️ Обработка
    [D] ← Последний добавленный
    [C]
    [B]
    [A] ← Первый добавленный
     ⬇️ Добавление

Timeline: [1 second per tick]
Calls:        ⬇️  ⬇️  ⬇️     ⬇️
Queue:       [ABC]   [AB]    [A]    []
Processed:    C       B       A
```

Поведение стека особенно полезно для:
- Систем отмены/повтора, где последнее действие должно отменяться первым
- Навигации по истории браузера, где нужно вернуться на последнюю страницу
- Стеков вызовов функций в реализациях языков программирования
- Алгоритмов обхода в глубину (depth-first traversal)

```ts
const stack = new Queuer<number>({
  addItemsTo: 'back', // по умолчанию
  getItemsFrom: 'back', // переопределение для поведения стека
})
stack.addItem(1) // [1]
stack.addItem(2) // [1, 2]
// Элементы обрабатываются в порядке: 2, затем 1

stack.getNextItem('back') // получить следующий элемент с конца очереди вместо начала
```

#### Приоритетная очередь (Priority Queue)

Приоритетные очереди добавляют дополнительное измерение упорядочивания, позволяя сортировать элементы по приоритету, а не только по порядку добавления. Каждому элементу присваивается значение приоритета, и очередь автоматически поддерживает элементы в порядке приоритета.

```text
Визуализация приоритетной очереди:

Добавление →  [P:5][P:3][P:2][P:1] → Обработка
              ⬇️           ⬆️
         Элементы с       Элементы с
         высоким приоритетом  низким приоритетом
                          обрабатываются последними

Timeline: [1 second per tick]
Calls:        ⬇️(P:2)  ⬇️(P:5)  ⬇️(P:1)     ⬇️(P:3)
Queue:       [2]      [5,2]    [5,2,1]    [3,2,1]    [2,1]    [1]    []
Processed:              5         -          3         2        1
```

Приоритетные очереди необходимы для:
- Планировщиков задач, где некоторые задачи более срочные
- Маршрутизации сетевых пакетов, где определенные типы трафика требуют приоритетной обработки
- Систем событий, где события с высоким приоритетом должны обрабатываться первыми
- Распределения ресурсов, где некоторые запросы важнее других

```ts
const priorityQueue = new Queuer<number>({
  getPriority: (n) => n // Большие числа имеют более высокий приоритет
})
priorityQueue.addItem(1) // [1]
priorityQueue.addItem(3) // [3, 1]
priorityQueue.addItem(2) // [3, 2, 1]
// Обрабатывает: 3, 2, затем 1
```

### Запуск и остановка

Класс `Queuer` поддерживает запуск и остановку обработки через методы `start()` и `stop()`, а также может быть настроен на автоматический запуск с помощью опции `started`:

```ts
const queue = new Queuer<number>({ 
  wait: 1000,
  started: false // Начинать в остановленном состоянии
})

// Управление обработкой
queue.start() // Начать обработку элементов
queue.stop()  // Приостановить обработку

// Проверка состояния обработки
console.log(queue.getIsRunning()) // Активна ли обработка очереди
console.log(queue.getIsIdle())    // Работает ли очередь, но пуста
```

Если вы используете адаптер фреймворка, где опции очереди реактивны, вы можете установить опцию `started` в условное значение:

```ts
const queue = useQueuer(
  processItem, 
  { 
    wait: 1000,
    started: isOnline // Запуск/остановка на основе статуса соединения, ЕСЛИ используется адаптер фреймворка с поддержкой реактивных опций
  }
)
```

### Дополнительные функции

`Queuer` предоставляет несколько полезных методов для управления очередью:

```ts
// Инспекция очереди
queue.getPeek()           // Просмотр следующего элемента без его удаления
queue.getSize()          // Получение текущего размера очереди
queue.getIsEmpty()       // Проверка, пуста ли очередь
queue.getIsFull()        // Проверка, достигла ли очередь maxSize
queue.getAllItems()   // Получение копии всех элементов в очереди

// Манипуляции с очередью
queue.clear()         // Удаление всех элементов
queue.reset()         // Сброс в начальное состояние
queue.getExecutionCount() // Получение количества обработанных элементов

// Обработка событий
queue.onItemsChange((item) => {
  console.log('Обработано:', item)
})
```

### Обработка отклонений

Когда очередь достигает максимального размера (установленного опцией `maxSize`), новые элементы будут отклоняться. `Queuer` предоставляет способы обработки и мониторинга этих отклонений:

```ts
const queue = new Queuer<number>({
  maxSize: 2, // Разрешить только 2 элемента в очереди
  onReject: (item, queuer) => {
    console.log('Очередь заполнена. Элемент отклонен:', item)
  }
})

queue.addItem(1) // Принят
queue.addItem(2) // Принят
queue.addItem(3) // Отклонен, вызывает onReject callback

console.log(queue.getRejectionCount()) // 1
```

### Начальные элементы

Вы можете предварительно заполнить очередь элементами при создании:

```ts
const queue = new Queuer<number>({
  initialItems: [1, 2, 3],
  started: true // Начать обработку немедленно
})

// Очередь начинается с [1, 2, 3] и начинает обработку
```

### Динамическая конфигурация

Опции `Queuer` могут быть изменены после создания с помощью `setOptions()` и получены с помощью `getOptions()`:

```ts
const queue = new Queuer<number>({
  wait: 1000,
  started: false
})

// Изменение конфигурации
queue.setOptions({
  wait: 500, // Обработка элементов в два раза быстрее
  started: true // Начать обработку
})

// Получение текущей конфигурации
const options = queue.getOptions()
console.log(options.wait) // 500
```

### Мониторинг производительности

`Queuer` предоставляет методы для мониторинга его производительности:

```ts
const queue = new Queuer<number>()

// Добавление и обработка некоторых элементов
queue.addItem(1)
queue.addItem(2)
queue.addItem(3)

console.log(queue.getExecutionCount()) // Количество обработанных элементов
console.log(queue.getRejectionCount()) // Количество отклоненных элементов
```

### Асинхронные очереди

Для обработки асинхронных операций с несколькими исполнителями (workers) см. [Руководство по асинхронным очередям](../guides/async-queueing), где рассматривается класс `AsyncQueuer`.

### Адаптеры фреймворков

Каждый адаптер фреймворка предоставляет удобные хуки и функции вокруг классов очередей. Хуки, такие как `useQueuer` или `useQueueState`, представляют собой небольшие обертки, которые могут сократить шаблонный код для некоторых распространенных случаев использования.
