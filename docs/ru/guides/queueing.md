---
source-updated-at: '2025-05-05T07:34:55.000Z'
translation-updated-at: '2025-05-06T23:19:59.827Z'
title: Руководство по очереди
id: queueing
---
# Руководство по очереди (Queueing Guide)

В отличие от [ограничения скорости (Rate Limiting)](../guides/rate-limiting), [троттлинга (Throttling)](../guides/throttling) и [дебаунсинга (Debouncing)](../guides/debouncing), которые отбрасывают вызовы при слишком частом выполнении, очереди (queuers) можно настроить так, чтобы каждая операция была обработана. Они предоставляют способ управления и контроля потока операций без потери запросов. Это делает их идеальными для сценариев, где потеря данных недопустима. Очередь также можно ограничить по максимальному размеру, что полезно для предотвращения утечек памяти или других проблем. В этом руководстве рассматриваются концепции очереди в TanStack Pacer.

## Концепция очереди (Queueing)

Очередь гарантирует, что каждая операция будет обработана, даже если они поступают быстрее, чем могут быть выполнены. В отличие от других техник контроля выполнения, которые отбрасывают избыточные операции, очередь буферизует операции в упорядоченном списке и обрабатывает их по определенным правилам. Это делает очередь единственной "безпотерьной" (lossless) техникой контроля выполнения в TanStack Pacer, если только не указан параметр `maxSize`, который может привести к отклонению элементов при заполнении буфера.

### Визуализация очереди (Queueing)

```text
Queueing (processing one item every 2 ticks)
Timeline: [1 second per tick]
Calls:        ⬇️  ⬇️  ⬇️     ⬇️  ⬇️     ⬇️  ⬇️  ⬇️
Queue:       [ABC]   [BC]    [BCDE]    [DE]    [E]    []
Executed:     ✅     ✅       ✅        ✅      ✅     ✅
             [=================================================================]
             ^ В отличие от rate limiting/throttling/debouncing,
               ВСЕ вызовы в итоге обрабатываются по порядку

             [Элементы накапливаются]   [Постепенная обработка]   [Очередь пуста]
              при занятости              по одному                 
```

### Когда использовать очередь (Queueing)

Очередь особенно важна, когда необходимо гарантировать обработку каждой операции, даже если это влечет задержку. Это делает ее идеальной для сценариев, где целостность и полнота данных важнее немедленного выполнения. При использовании `maxSize` она также может служить буфером для предотвращения перегрузки системы слишком большим количеством ожидающих операций.

Типичные сценарии использования:
- Предварительная загрузка данных без перегрузки системы
- Обработка пользовательских взаимодействий в UI, где каждое действие должно быть записано
- Выполнение операций с базой данных, требующих сохранения целостности данных
- Управление API-запросами, которые должны завершиться успешно
- Координация фоновых задач, которые нельзя отменить
- Анимационные последовательности, где важен каждый кадр
- Отправка форм, где каждая запись должна быть сохранена
- Буферизация потоков данных с фиксированной емкостью через `maxSize`

### Когда не использовать очередь (Queueing)

Очередь может быть не лучшим выбором, когда:
- Немедленная обратная связь важнее обработки каждой операции
- Важно только последнее значение (используйте [дебаунсинг (debouncing)](../guides/debouncing))

> [!TIP]
> Если вы используете ограничение скорости, троттлинг или дебаунсинг, но столкнулись с проблемами из-за отброшенных операций, очередь, скорее всего, — решение, которое вам нужно.

## Очередь в TanStack Pacer

TanStack Pacer предоставляет функциональность очереди через простую функцию `queue` и более мощный класс `Queuer`. В то время как другие техники контроля выполнения обычно используют функциональные API, очередь часто выигрывает от дополнительного контроля, предоставляемого классом.

### Базовое использование с `queue`

Функция `queue` предоставляет простой способ создания постоянно работающей очереди, которая обрабатывает элементы по мере их добавления:

```ts
import { queue } from '@tanstack/pacer'

// Создаем очередь, обрабатывающую элементы каждую секунду
const processItems = queue<number>({
  wait: 1000,
  maxSize: 10, // Опционально: ограничить размер очереди для предотвращения проблем с памятью или временем
  onItemsChange: (queuer) => {
    console.log('Текущая очередь:', queuer.getAllItems())
  }
})

// Добавляем элементы для обработки
processItems(1) // Обрабатывается немедленно
processItems(2) // Обрабатывается через 1 секунду
processItems(3) // Обрабатывается через 2 секунды
```

Хотя функция `queue` проста в использовании, она предоставляет только базовую постоянно работающую очередь через метод `addItem`. Для большинства случаев потребуется дополнительный контроль и функции класса `Queuer`.

### Продвинутое использование с классом `Queuer`

Класс `Queuer` предоставляет полный контроль над поведением очереди и обработкой:

```ts
import { Queuer } from '@tanstack/pacer'

// Создаем очередь, обрабатывающую элементы каждую секунду
const queue = new Queuer<number>({
  wait: 1000, // Ожидание 1 секунды между обработкой элементов
  maxSize: 5, // Опционально: ограничить размер очереди для предотвращения проблем с памятью или временем
  onItemsChange: (queuer) => {
    console.log('Текущая очередь:', queuer.getAllItems())
  }
})

// Начинаем обработку
queue.start()

// Добавляем элементы для обработки
queue.addItem(1)
queue.addItem(2)
queue.addItem(3)

// Элементы будут обрабатываться по одному с задержкой в 1 секунду
// Вывод:
// Обработка: 1 (немедленно)
// Обработка: 2 (через 1 секунду)
// Обработка: 3 (через 2 секунды)
```

### Типы очередей и порядок обработки

Уникальность `Queuer` в TanStack Pacer заключается в его способности адаптироваться к различным сценариям через API, основанный на позициях. Один и тот же `Queuer` может вести себя как традиционная очередь (queue), стек (stack) или двусторонняя очередь (double-ended queue), используя один и тот же интерфейс.

#### FIFO очередь (First In, First Out)

Поведение по умолчанию, при котором элементы обрабатываются в порядке их добавления. Это наиболее распространенный тип очереди, следующий принципу "первым пришел — первым ушел". При использовании `maxSize` новые элементы будут отклоняться, если очередь заполнена.

```text
Визуализация FIFO очереди (с maxSize=3):

Добавление →  [A][B][C] → Обработка
              ⬇️     ⬆️
           Новые элементы   Элементы
           добавляются тут  обрабатываются тут
           (отклоняются, если очередь полна)

Timeline: [1 second per tick]
Calls:        ⬇️  ⬇️  ⬇️     ⬇️  ⬇️
Queue:       [ABC]   [BC]    [C]    []
Processed:    A       B       C
Rejected:     D      E
```

FIFO очереди идеальны для:
- Обработки задач, где важен порядок
- Очередей сообщений, где сообщения должны обрабатываться последовательно
- Очередей печати, где документы должны печататься в порядке отправки
- Систем обработки событий, где события должны обрабатываться в хронологическом порядке

```ts
const queue = new Queuer<number>({
  addItemsTo: 'back', // по умолчанию
  getItemsFrom: 'front', // по умолчанию
})
queue.addItem(1) // [1]
queue.addItem(2) // [1, 2]
// Обработка: 1, затем 2
```

#### LIFO стек (Last In, First Out)

Указав 'back' как позицию для добавления и извлечения элементов, `Queuer` ведет себя как стек. В стеке последний добавленный элемент обрабатывается первым. При использовании `maxSize` новые элементы будут отклоняться, если стек заполнен.

```text
Визуализация LIFO стека (с maxSize=3):

     ⬆️ Обработка
    [C] ← Последний добавленный
    [B]
    [A] ← Первый добавленный
     ⬇️ Добавление
     (отклоняются, если стек полон)

Timeline: [1 second per tick]
Calls:        ⬇️  ⬇️  ⬇️     ⬇️  ⬇️
Queue:       [ABC]   [AB]    [A]    []
Processed:    C       B       A
Rejected:     D      E
```

Стеки особенно полезны для:
- Систем отмены/повтора, где последнее действие должно отменяться первым
- Навигации в истории браузера, где нужно вернуться на последнюю страницу
- Стеков вызовов функций в реализациях языков программирования
- Алгоритмов обхода в глубину (depth-first traversal)

```ts
const stack = new Queuer<number>({
  addItemsTo: 'back', // по умолчанию
  getItemsFrom: 'back', // переопределение для поведения стека
})
stack.addItem(1) // [1]
stack.addItem(2) // [1, 2]
// Элементы обрабатываются в порядке: 2, затем 1

stack.getNextItem('back') // получить следующий элемент с конца очереди вместо начала
```

#### Приоритетная очередь (Priority Queue)

Приоритетные очереди добавляют дополнительное измерение к упорядочиванию, позволяя сортировать элементы по их приоритету, а не только по порядку добавления. Каждому элементу присваивается значение приоритета, и очередь автоматически поддерживает элементы в порядке приоритета. При использовании `maxSize` элементы с низким приоритетом могут быть отклонены, если очередь заполнена.

```text
Визуализация приоритетной очереди (с maxSize=3):

Добавление →  [P:5][P:3][P:2] → Обработка
              ⬇️           ⬆️
         Высокий приоритет   Низкий приоритет
         элементы тут        обрабатываются последними
         (отклоняются, если очередь полна)

Timeline: [1 second per tick]
Calls:        ⬇️(P:2)  ⬇️(P:5)  ⬇️(P:1)     ⬇️(P:3)
Queue:       [2]      [5,2]    [5,2,1]    [3,2,1]    [2,1]    [1]    []
Processed:              5         -          3         2        1
Rejected:                         4
```

Приоритетные очереди необходимы для:
- Планировщиков задач, где некоторые задачи более срочные
- Маршрутизации сетевых пакетов, где определенные типы трафика требуют приоритета
- Систем событий, где высокоприоритетные события должны обрабатываться первыми
- Распределения ресурсов, где некоторые запросы важнее других

```ts
const priorityQueue = new Queuer<number>({
  getPriority: (n) => n // Большие числа имеют более высокий приоритет
})
priorityQueue.addItem(1) // [1]
priorityQueue.addItem(3) // [3, 1]
priorityQueue.addItem(2) // [3, 2, 1]
// Обработка: 3, 2, затем 1
```

### Запуск и остановка

Класс `Queuer` поддерживает запуск и остановку обработки через методы `start()` и `stop()`, а также может быть настроен на автоматический запуск с помощью опции `started`:

```ts
const queue = new Queuer<number>({ 
  wait: 1000,
  started: false // Начать в остановленном состоянии
})

// Управление обработкой
queue.start() // Начать обработку элементов
queue.stop()  // Приостановить обработку

// Проверка состояния обработки
console.log(queue.getIsRunning()) // Активна ли обработка очереди
console.log(queue.getIsIdle())    // Работает ли очередь, но пуста
```

Если вы используете адаптер для фреймворка с реактивными опциями, можно задать опцию `started` как условное значение:

```ts
const queue = useQueuer(
  processItem, 
  { 
    wait: 1000,
    started: isOnline // Запуск/остановка на основе статуса соединения, ЕСЛИ используется адаптер фреймворка с поддержкой реактивных опций
  }
)
```

### Дополнительные функции

`Queuer` предоставляет несколько полезных методов для управления очередью:

```ts
// Инспекция очереди
queue.getPeek()           // Просмотр следующего элемента без удаления
queue.getSize()          // Получение текущего размера очереди
queue.getIsEmpty()       // Проверка, пуста ли очередь
queue.getIsFull()        // Проверка, достигла ли очередь maxSize
queue.getAllItems()   // Получение копии всех элементов в очереди

// Управление очередью
queue.clear()         // Удаление всех элементов
queue.reset()         // Сброс в начальное состояние
queue.getExecutionCount() // Получение количества обработанных элементов

// Обработка событий
queue.onItemsChange((item) => {
  console.log('Обработано:', item)
})
```

### Истечение срока элементов (Item Expiration)

`Queuer` поддерживает автоматическое истечение срока элементов, находящихся в очереди слишком долго. Это полезно для предотвращения обработки устаревших данных или реализации таймаутов для операций в очереди.

```ts
const queue = new Queuer<number>({
  expirationDuration: 5000, // Элементы истекают через 5 секунд
  onExpire: (item, queuer) => {
    console.log('Элемент истек:', item)
  }
})

// Или использовать пользовательскую проверку истечения
const queue = new Queuer<number>({
  getIsExpired: (item, addedAt) => {
    // Пользовательская логика истечения
    return Date.now() - addedAt > 5000
  },
  onExpire: (item, queuer) => {
    console.log('Элемент истек:', item)
  }
})

// Проверка статистики истечения
console.log(queue.getExpirationCount()) // Количество истекших элементов
```

Функции истечения особенно полезны для:
- Предотвращения обработки устаревших данных
- Реализации таймаутов для операций в очереди
- Управления использованием памяти путем автоматического удаления старых элементов
- Обработки временных данных, действительных только ограниченное время

### Обработка отклонений (Rejection Handling)

При достижении максимального размера очереди (установленного опцией `maxSize`) новые элементы будут отклоняться. `Queuer` предоставляет способы обработки и мониторинга этих отклонений:

```ts
const queue = new Queuer<number>({
  maxSize: 2, // Разрешить только 2 элемента в очереди
  onReject: (item, queuer) => {
    console.log('Очередь полна. Элемент отклонен:', item)
  }
})

queue.addItem(1) // Принят
queue.addItem(2) // Принят
queue.addItem(3) // Отклонен, вызывает callback onReject

console.log(queue.getRejectionCount()) // 1
```

### Начальные элементы (Initial Items)

Очередь можно предварительно заполнить начальными элементами при создании:

```ts
const queue = new Queuer<number>({
  initialItems: [1, 2, 3],
  started: true // Начать обработку немедленно
})

// Очередь начинается с [1, 2, 3] и сразу начинает обработку
```

### Динамическая конфигурация (Dynamic Configuration)

Опции `Queuer` можно изменять после создания с помощью `setOptions()` и получать текущие настройки через `getOptions()`:

```ts
const queue = new Queuer<number>({
  wait: 1000,
  started: false
})

// Изменение конфигурации
queue.setOptions({
  wait: 500, // Обрабатывать элементы в два раза быстрее
  started: true // Начать обработку
})

// Получение текущей конфигурации
const options = queue.getOptions()
console.log(options.wait) // 500
```

### Мониторинг производительности (Performance Monitoring)

`Queuer` предоставляет методы для мониторинга его производительности:

```ts
