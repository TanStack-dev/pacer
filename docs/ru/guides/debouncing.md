---
source-updated-at: '2025-05-05T07:34:55.000Z'
translation-updated-at: '2025-05-06T23:19:56.587Z'
title: Руководство по дебаунсингу
id: debouncing
---
# Руководство по Дебаунсингу (Debouncing)

Rate Limiting (ограничение частоты), Throttling (троттлинг) и Debouncing (дебаунсинг) — это три различных подхода к контролю частоты выполнения функций. Каждая техника по-разному блокирует выполнение, делая их "потерянными" (lossy) — это означает, что некоторые вызовы функций не будут выполнены, если они запрашиваются слишком часто. Понимание того, когда использовать каждый подход, крайне важно для создания производительных и надежных приложений. В этом руководстве рассматриваются концепции дебаунсинга в TanStack Pacer.

## Концепция Дебаунсинга (Debouncing)

Дебаунсинг — это техника, которая откладывает выполнение функции до тех пор, пока не пройдет указанный период бездействия. В отличие от ограничения частоты (rate limiting), которое допускает всплески вызовов до определенного предела, или троттлинга (throttling), который обеспечивает равномерное выполнение, дебаунсинг объединяет несколько быстрых вызовов функции в одно выполнение, которое происходит только после остановки вызовов. Это делает дебаунсинг идеальным для обработки всплесков событий, где важно только конечное состояние после завершения активности.

### Визуализация Дебаунсинга

```text
Debouncing (wait: 3 ticks)
Timeline: [1 second per tick]
Calls:        ⬇️  ⬇️  ⬇️  ⬇️  ⬇️     ⬇️  ⬇️  ⬇️  ⬇️               ⬇️  ⬇️
Executed:     ❌  ❌  ❌  ❌  ❌     ❌  ❌  ❌  ⏳   ->   ✅     ❌  ⏳   ->    ✅
             [=================================================================]
                                                        ^ Выполняется здесь после
                                                         3 тиков без вызовов

             [Всплеск вызовов]     [Еще вызовы]   [Ожидание]      [Новый всплеск]
             Нет выполнения        Сброс таймера    [Отложенное выполнение]  [Ожидание] [Отложенное выполнение]
```

### Когда Использовать Дебаунсинг

Дебаунсинг особенно эффективен, когда нужно дождаться "паузы" в активности перед выполнением действия. Это делает его идеальным для обработки пользовательского ввода или других быстро повторяющихся событий, где важно только конечное состояние.

Распространенные сценарии использования:
- Поля поиска, где нужно дождаться окончания ввода пользователем
- Валидация форм, которая не должна запускаться при каждом нажатии клавиши
- Расчеты при изменении размера окна, которые требуют больших вычислений
- Автосохранение черновиков при редактировании контента
- API-вызовы, которые должны выполняться только после завершения активности пользователя
- Любые сценарии, где важно только конечное значение после быстрых изменений

### Когда Не Использовать Дебаунсинг

Дебаунсинг может быть не лучшим выбором, когда:
- Нужно гарантированное выполнение в течение определенного периода (используйте [троттлинг](../guides/throttling))
- Нельзя пропускать ни одного выполнения (используйте [очередь (queueing)](../guides/queueing))

## Дебаунсинг в TanStack Pacer

TanStack Pacer предоставляет как синхронный, так и асинхронный дебаунсинг через классы `Debouncer` и `AsyncDebouncer` соответственно (и соответствующие функции `debounce` и `asyncDebounce`).

### Базовое Использование с `debounce`

Функция `debounce` — это самый простой способ добавить дебаунсинг к любой функции:

```ts
import { debounce } from '@tanstack/pacer'

// Дебаунсинг поля поиска для ожидания окончания ввода
const debouncedSearch = debounce(
  (searchTerm: string) => performSearch(searchTerm),
  {
    wait: 500, // Ждать 500 мс после последнего нажатия
  }
)

searchInput.addEventListener('input', (e) => {
  debouncedSearch(e.target.value)
})
```

### Продвинутое Использование с Классом `Debouncer`

Для большего контроля над поведением дебаунсинга можно использовать класс `Debouncer` напрямую:

```ts
import { Debouncer } from '@tanstack/pacer'

const searchDebouncer = new Debouncer(
  (searchTerm: string) => performSearch(searchTerm),
  { wait: 500 }
)

// Получение информации о текущем состоянии
console.log(searchDebouncer.getExecutionCount()) // Количество успешных выполнений
console.log(searchDebouncer.getIsPending()) // Есть ли ожидающий вызов

// Динамическое обновление параметров
searchDebouncer.setOptions({ wait: 1000 }) // Увеличение времени ожидания

// Отмена ожидающего выполнения
searchDebouncer.cancel()
```

### Выполнение на Начале и Конце

Синхронный дебаунсер поддерживает выполнение как на начальном (leading), так и на конечном (trailing) этапе:

```ts
const debouncedFn = debounce(fn, {
  wait: 500,
  leading: true,   // Выполнить при первом вызове
  trailing: true,  // Выполнить после периода ожидания
})
```

- `leading: true` — Функция выполняется сразу при первом вызове
- `leading: false` (по умолчанию) — Первый вызов запускает таймер ожидания
- `trailing: true` (по умолчанию) — Функция выполняется после периода ожидания
- `trailing: false` — Нет выполнения после периода ожидания

Распространенные паттерны:
- `{ leading: false, trailing: true }` — По умолчанию, выполнение после ожидания
- `{ leading: true, trailing: false }` — Выполнить сразу, игнорировать последующие вызовы
- `{ leading: true, trailing: true }` — Выполнить как при первом вызове, так и после ожидания

### Максимальное Время Ожидания

Дебаунсер TanStack Pacer намеренно НЕ имеет опции `maxWait`, в отличие от других библиотек дебаунсинга. Если нужно, чтобы выполнение происходило в более распределенный период времени, рассмотрите использование техники [троттлинга](../guides/throttling).

### Включение/Отключение

Класс `Debouncer` поддерживает включение/отключение через опцию `enabled`. Используя метод `setOptions`, можно включать/отключать дебаунсер в любое время:

```ts
const debouncer = new Debouncer(fn, { wait: 500, enabled: false }) // Отключен по умолчанию
debouncer.setOptions({ enabled: true }) // Включить в любое время
```

Если используется адаптер для фреймворка, где параметры дебаунсера реактивны, можно установить опцию `enabled` в условное значение для динамического включения/отключения:

```ts
// Пример для React
const debouncer = useDebouncer(
  setSearch, 
  { wait: 500, enabled: searchInput.value.length > 3 } // Включить/отключить в зависимости от длины ввода, ЕСЛИ используется адаптер фреймворка с поддержкой реактивных параметров
)
```

Однако при использовании функции `debounce` или класса `Debouncer` напрямую необходимо использовать метод `setOptions` для изменения опции `enabled`, так как переданные параметры фактически передаются в конструктор класса `Debouncer`.

```ts
// Пример для Solid
const debouncer = new Debouncer(fn, { wait: 500, enabled: false }) // Отключен по умолчанию
createEffect(() => {
  debouncer.setOptions({ enabled: search().length > 3 }) // Включить/отключить в зависимости от длины ввода
})
```

### Опции Колбэков

Как синхронный, так и асинхронный дебаунсеры поддерживают опции колбэков для обработки различных аспектов жизненного цикла дебаунсинга:

#### Колбэки Синхронного Дебаунсера

Синхронный `Debouncer` поддерживает следующий колбэк:

```ts
const debouncer = new Debouncer(fn, {
  wait: 500,
  onExecute: (debouncer) => {
    // Вызывается после каждого успешного выполнения
    console.log('Функция выполнена', debouncer.getExecutionCount())
  }
})
```

Колбэк `onExecute` вызывается после каждого успешного выполнения дебаунсированной функции, что полезно для отслеживания выполнений, обновления состояния UI или выполнения операций очистки.

#### Колбэки Асинхронного Дебаунсера

Асинхронный `AsyncDebouncer` имеет другой набор колбэков по сравнению с синхронной версией.

```ts
const asyncDebouncer = new AsyncDebouncer(async (value) => {
  await saveToAPI(value)
}, {
  wait: 500,
  onSuccess: (result, debouncer) => {
    // Вызывается после каждого успешного выполнения
    console.log('Асинхронная функция выполнена', debouncer.getSuccessCount())
  },
  onSettled: (debouncer) => {
    // Вызывается после каждой попытки выполнения
    console.log('Асинхронная функция завершена', debouncer.getSettledCount())
  },
  onError: (error) => {
    // Вызывается при ошибке в асинхронной функции
    console.error('Асинхронная функция завершилась с ошибкой:', error)
  }
})
```

Колбэк `onSuccess` вызывается после каждого успешного выполнения дебаунсированной функции, а `onError` — если асинхронная функция выбрасывает ошибку. Колбэк `onSettled` вызывается после каждой попытки выполнения, независимо от успеха или ошибки. Эти колбэки особенно полезны для отслеживания количества выполнений, обновления состояния UI, обработки ошибок, выполнения операций очистки и логирования метрик выполнения.

### Асинхронный Дебаунсинг

Асинхронный дебаунсер предоставляет мощный способ обработки асинхронных операций с дебаунсингом, предлагая несколько ключевых преимуществ по сравнению с синхронной версией. В то время как синхронный дебаунсер отлично подходит для событий UI и мгновенной обратной связи, асинхронная версия специально разработана для обработки API-вызовов, операций с базой данных и других асинхронных задач.

#### Ключевые Отличия от Синхронного Дебаунсинга

1. **Обработка Возвращаемого Значения**
В отличие от синхронного дебаунсера, который возвращает void, асинхронная версия позволяет захватывать и использовать возвращаемое значение из дебаунсированной функции. Это особенно полезно при работе с результатами API-вызовов или других асинхронных операций. Метод `maybeExecute` возвращает Promise, который разрешается с возвращаемым значением функции, позволяя ожидать результат и обрабатывать его соответствующим образом.

2. **Расширенная Система Колбэков**
Асинхронный дебаунсер предоставляет более сложную систему колбэков по сравнению с единственным колбэком `onExecute` в синхронной версии. Эта система включает:
- `onSuccess`: Вызывается при успешном завершении асинхронной функции, предоставляя как результат, так и экземпляр дебаунсера
- `onError`: Вызывается при ошибке в асинхронной функции, предоставляя как ошибку, так и экземпляр дебаунсера
- `onSettled`: Вызывается после каждой попытки выполнения, независимо от успеха или ошибки

3. **Отслеживание Выполнений**
Асинхронный дебаунсер предоставляет комплексное отслеживание выполнений через несколько методов:
- `getSuccessCount()`: Количество успешных выполнений
- `getErrorCount()`: Количество неудачных выполнений
- `getSettledCount()`: Общее количество завершенных выполнений (успешные + неудачные)

4. **Последовательное Выполнение**
Асинхронный дебаунсер гарантирует, что последующие выполнения ждут завершения предыдущего вызова перед началом. Это предотвращает выполнение в неправильном порядке и гарантирует, что каждый вызов обрабатывает самые актуальные данные. Это особенно важно при работе с операциями, которые зависят от результатов предыдущих вызовов, или когда критически важна согласованность данных.

Например, если обновляется профиль пользователя и затем сразу же запрашиваются обновленные данные, асинхронный дебаунсер гарантирует, что операция запроса дождется завершения обновления, предотвращая состояния гонки (race conditions), при которых можно получить устаревшие данные.

#### Пример Базового Использования

Вот базовый пример использования асинхронного дебаунсера для операции поиска:

```ts
const debouncedSearch = asyncDebounce(
  async (searchTerm: string) => {
    const results = await fetchSearchResults(searchTerm)
    return results
  },
  {
    wait: 500,
    onSuccess: (results, debouncer) => {
      console.log('Поиск успешен:', results)
    },
    onError: (error, debouncer) => {
      console.error('Поиск завершился ошибкой:', error)
    }
  }
)

// Использование
const results = await debouncedSearch('query')
```

#### Продвинутые Паттерны

Асинхронный дебаунсер можно комбинировать с различными паттернами для решения сложных задач:

1. **Интеграция с Управлением Состоянием**
При использовании асинхронного дебаунсера с системами управления состоянием (например, useState в React или createSignal в Solid) можно создавать мощные паттерны для обработки состояний загрузки, ошибок и обновления данных. Колбэки дебаунсера предоставляют идеальные хуки для обновления состояния UI на основе успеха или ошибки операций.

2. **Предотвращение Состояний Гонки**
Паттерн единичной мутации (single-flight mutation) естественным образом предотвращает состояния гонки во многих сценариях. Когда несколько частей приложения пытаются одновременно обновить один и тот же ресурс, дебаунсер гарантирует, что выполнится только самое последнее обновление, при этом предоставляя результаты всем вызывающим сторонам.

3. **Восстановление после Ошибок**
Возможности обработки ошибок асинхронного дебаунсера делают его идеальным для реализации логики повторных попыток и восстановления после ошибок. Можно использовать колбэк `onError` для реализации пользовательских стратегий обработки ошибок, таких как экспоненциальная задержка (exponential backoff) или механизмы отката (fallback).

### Адаптеры для Фреймворков

Каждый адаптер для фреймворка предоставляет хуки, которые расширяют базовую функциональность дебаунсинга для интеграции с системой управления состоянием фреймворка. Для каждого фреймворка доступны хуки, такие как `createDebouncer`, `useDebouncedCallback`, `useDebouncedState` или `useDebouncedValue`.

Вот несколько примеров:

#### React

```tsx
import { useDebouncer, useDebouncedCallback, useDebouncedValue } from '@tanstack/react-pacer'

// Низкоуровневый хук для полного контроля
const debouncer = useDebouncer(
  (value: string) => saveToDatabase(value),
  { wait: 500 }
)

// Простой хук для базовых сценариев
const handleSearch = useDebouncedCallback(
  (query: string) => fetchSearchResults(query),
  { wait: 500 }
)

// Хук на основе состояния для реактивного управления состоянием
const [instantState, setInstantState] = useState('')
const [debouncedValue] = useDebouncedValue(
  instantState, // Значение для дебаунсинга
  { wait: 500 }
)
```

#### Solid

```tsx
import { createDebouncer, createDebouncedSignal } from '@tanstack/solid-pacer'

// Низкоуровневый хук для полного контроля
const debouncer = createDebouncer(
  (value: string) => saveToDatabase(value),
  { wait: 500 }
)

// Хук на основе сигналов для управления состоянием
const [searchTerm, setSearchTerm, debouncer] = createDebouncedSignal('', {
  wait: 500,
  onExecute: (debouncer) => {
    console.log('Всего выполнений:', debouncer.getExecutionCount())
  }
})
```
