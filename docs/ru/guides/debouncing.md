---
source-updated-at: '2025-04-24T12:27:47.000Z'
translation-updated-at: '2025-05-02T04:37:10.942Z'
title: Руководство по дебаунсингу
id: debouncing
---
# Руководство по дебаунсингу (Debouncing)

TanStack Pacer — это библиотека, предоставляющая высококачественные утилиты для управления временем выполнения функций в ваших приложениях. Хотя подобные инструменты существуют и в других библиотеках, мы стремимся к идеальной реализации всех важных аспектов, включая ***типобезопасность (type-safety)***, ***tree-shaking*** и ***интуитивно понятный API (intuitive API)***. Сосредоточившись на этих основах и сделав их доступными в ***независимом от фреймворков (framework agnostic)*** формате, мы надеемся, что эти утилиты и паттерны станут более распространёнными в ваших приложениях. Правильное управление выполнением часто упускается из виду при разработке приложений, что приводит к проблемам с производительностью, состоянию гонки (race conditions) и плохому пользовательскому опыту, которых можно было избежать. TanStack Pacer помогает правильно реализовать эти важные паттерны с самого начала!

Ограничение частоты (Rate Limiting), троттлинг (Throttling) и дебаунсинг (Debouncing) — это три различных подхода к контролю частоты выполнения функций. Каждый метод блокирует выполнение по-своему, делая их «потерянными» (lossy) — это означает, что некоторые вызовы функций не будут выполнены, если они запрашиваются слишком часто. Понимание того, когда использовать каждый подход, крайне важно для создания производительных и надёжных приложений. В этом руководстве рассматриваются концепции дебаунсинга в TanStack Pacer.

## Концепция дебаунсинга (Debouncing)

Дебаунсинг — это техника, которая откладывает выполнение функции до тех пор, пока не пройдёт указанный период бездействия. В отличие от ограничения частоты (rate limiting), которое допускает всплески вызовов до определённого предела, или троттлинга (throttling), который обеспечивает равномерное выполнение, дебаунсинг объединяет несколько быстрых вызовов функции в одно выполнение, которое происходит только после остановки вызовов. Это делает дебаунсинг идеальным для обработки всплесков событий, когда вас интересует только конечное состояние после завершения активности.

### Визуализация дебаунсинга

```text
Debouncing (wait: 3 ticks)
Timeline: [1 second per tick]
Calls:        ⬇️  ⬇️  ⬇️  ⬇️  ⬇️     ⬇️  ⬇️  ⬇️  ⬇️               ⬇️  ⬇️
Executed:     ❌  ❌  ❌  ❌  ❌     ❌  ❌  ❌  ⏳   ->   ✅     ❌  ⏳   ->    ✅
             [=================================================================]
                                                        ^ Выполняется здесь после
                                                         3 тиков без вызовов

             [Всплеск вызовов]     [Ещё вызовы]   [Ожидание]      [Новый всплеск]
             Нет выполнения        Сброс таймера    [Отложенное выполнение]  [Ожидание] [Отложенное выполнение]
```

### Когда использовать дебаунсинг

Дебаунсинг особенно эффективен, когда вы хотите дождаться «паузы» в активности перед выполнением действия. Это делает его идеальным для обработки пользовательского ввода или других быстро повторяющихся событий, где важен только конечный результат.

Типичные сценарии использования:
- Поля поиска, где нужно дождаться окончания ввода пользователя
- Валидация форм, которая не должна запускаться при каждом нажатии клавиши
- Расчёты при изменении размера окна, которые требуют значительных ресурсов
- Автосохранение черновиков при редактировании контента
- API-запросы, которые должны выполняться только после завершения активности пользователя
- Любые сценарии, где важен только конечный результат после быстрых изменений

### Когда не использовать дебаунсинг

Дебаунсинг может быть не лучшим выбором, когда:
- Вам нужно гарантированное выполнение в определённый период времени (используйте [троттлинг](../guides/throttling))
- Вы не можете пропустить ни одного выполнения (используйте [очередь (queueing)](../guides/queueing))

## Дебаунсинг в TanStack Pacer

TanStack Pacer предоставляет как синхронный, так и асинхронный дебаунсинг через классы `Debouncer` и `AsyncDebouncer` соответственно (и соответствующие функции `debounce` и `asyncDebounce`).

### Базовое использование с `debounce`

Функция `debounce` — это самый простой способ добавить дебаунсинг к любой функции:

```ts
import { debounce } from '@tanstack/pacer'

// Дебаунсинг поля поиска для ожидания окончания ввода
const debouncedSearch = debounce(
  (searchTerm: string) => performSearch(searchTerm),
  {
    wait: 500, // Ждать 500 мс после последнего нажатия
  }
)

searchInput.addEventListener('input', (e) => {
  debouncedSearch(e.target.value)
})
```

### Расширенное использование с классом `Debouncer`

Для большего контроля над поведением дебаунсинга можно использовать класс `Debouncer` напрямую:

```ts
import { Debouncer } from '@tanstack/pacer'

const searchDebouncer = new Debouncer(
  (searchTerm: string) => performSearch(searchTerm),
  { wait: 500 }
)

// Получение информации о текущем состоянии
console.log(searchDebouncer.getExecutionCount()) // Количество успешных выполнений
console.log(searchDebouncer.getIsPending()) // Есть ли ожидающий вызов

// Динамическое обновление параметров
searchDebouncer.setOptions({ wait: 1000 }) // Увеличение времени ожидания

// Отмена ожидающего выполнения
searchDebouncer.cancel()
```

### Выполнение на переднем и заднем фронте (Leading and Trailing Executions)

Синхронный дебаунсер поддерживает выполнение как на переднем, так и на заднем фронте:

```ts
const debouncedFn = debounce(fn, {
  wait: 500,
  leading: true,   // Выполнить при первом вызове
  trailing: true,  // Выполнить после периода ожидания
})
```

- `leading: true` — Функция выполняется сразу при первом вызове
- `leading: false` (по умолчанию) — Первый вызов запускает таймер ожидания
- `trailing: true` (по умолчанию) — Функция выполняется после периода ожидания
- `trailing: false` — Нет выполнения после периода ожидания

Типичные паттерны:
- `{ leading: false, trailing: true }` — По умолчанию, выполнение после ожидания
- `{ leading: true, trailing: false }` — Выполнение сразу, игнорирование последующих вызовов
- `{ leading: true, trailing: true }` — Выполнение при первом вызове и после ожидания

### Максимальное время ожидания (Max Wait Time)

Дебаунсер TanStack Pacer НЕ имеет опции `maxWait`, в отличие от других библиотек. Если вам нужно распределить выполнение во времени, рассмотрите использование техники [троттлинга (throttling)](../guides/throttling).

### Включение/отключение

Класс `Debouncer` поддерживает включение/отключение через опцию `enabled`. Используя метод `setOptions`, вы можете включать/отключать дебаунсер в любое время:

```ts
const debouncer = new Debouncer(fn, { wait: 500, enabled: false }) // Отключён по умолчанию
debouncer.setOptions({ enabled: true }) // Включить в любое время
```

Если вы используете адаптер для фреймворка с реактивными опциями, вы можете установить опцию `enabled` в условное значение для динамического управления:

```ts
// Пример для React
const debouncer = useDebouncer(
  setSearch, 
  { wait: 500, enabled: searchInput.value.length > 3 } // Включение/отключение в зависимости от длины ввода, ЕСЛИ используется адаптер с реактивными опциями
)
```

Однако при использовании функции `debounce` или класса `Debouncer` напрямую необходимо использовать метод `setOptions` для изменения опции `enabled`, так как переданные параметры передаются в конструктор класса `Debouncer`.

```ts
// Пример для Solid
const debouncer = new Debouncer(fn, { wait: 500, enabled: false }) // Отключён по умолчанию
createEffect(() => {
  debouncer.setOptions({ enabled: search().length > 3 }) // Включение/отключение в зависимости от длины ввода
})
```

### Опции обратных вызовов (Callback Options)

Как синхронный, так и асинхронный дебаунсеры поддерживают опции обратных вызовов для обработки различных аспектов жизненного цикла дебаунсинга:

#### Обратные вызовы синхронного дебаунсера

Синхронный `Debouncer` поддерживает следующий обратный вызов:

```ts
const debouncer = new Debouncer(fn, {
  wait: 500,
  onExecute: (debouncer) => {
    // Вызывается после каждого успешного выполнения
    console.log('Функция выполнена', debouncer.getExecutionCount())
  }
})
```

Обратный вызов `onExecute` вызывается после каждого успешного выполнения дебаунсированной функции, что полезно для отслеживания выполнений, обновления состояния UI или выполнения операций очистки.

#### Обратные вызовы асинхронного дебаунсера

Асинхронный `AsyncDebouncer` поддерживает дополнительные обратные вызовы для обработки ошибок:

```ts
const asyncDebouncer = new AsyncDebouncer(async (value) => {
  await saveToAPI(value)
}, {
  wait: 500,
  onExecute: (debouncer) => {
    // Вызывается после каждого успешного выполнения
    console.log('Асинхронная функция выполнена', debouncer.getExecutionCount())
  },
  onError: (error) => {
    // Вызывается при ошибке в асинхронной функции
    console.error('Ошибка асинхронной функции:', error)
  }
})
```

Обратный вызов `onExecute` работает так же, как и в синхронном дебаунсере, а `onError` позволяет обрабатывать ошибки без прерывания цепочки дебаунсинга. Эти обратные вызовы особенно полезны для отслеживания количества выполнений, обновления состояния UI, обработки ошибок, выполнения операций очистки и логирования метрик.

### Асинхронный дебаунсинг

Для асинхронных функций или при необходимости обработки ошибок используйте `AsyncDebouncer` или `asyncDebounce`:

```ts
import { asyncDebounce } from '@tanstack/pacer'

const debouncedSearch = asyncDebounce(
  async (searchTerm: string) => {
    const results = await fetchSearchResults(searchTerm)
    updateUI(results)
  },
  {
    wait: 500,
    onError: (error) => {
      console.error('Ошибка поиска:', error)
    }
  }
)

// Будет выполнен только один API-запрос после остановки ввода
searchInput.addEventListener('input', async (e) => {
  await debouncedSearch(e.target.value)
})
```

Асинхронная версия предоставляет отслеживание выполнения на основе Promise, обработку ошибок через `onError`, корректную очистку ожидающих операций и метод `maybeExecute`, который можно ожидать.

### Адаптеры для фреймворков

Каждый адаптер для фреймворка предоставляет хуки, которые расширяют базовую функциональность дебаунсинга для интеграции с системой управления состоянием фреймворка. Для каждого фреймворка доступны хуки, такие как `createDebouncer`, `useDebouncedCallback`, `useDebouncedState` или `useDebouncedValue`.

Примеры:

#### React

```tsx
import { useDebouncer, useDebouncedCallback, useDebouncedValue } from '@tanstack/react-pacer'

// Низкоуровневый хук для полного контроля
const debouncer = useDebouncer(
  (value: string) => saveToDatabase(value),
  { wait: 500 }
)

// Простой хук обратного вызова для базовых сценариев
const handleSearch = useDebouncedCallback(
  (query: string) => fetchSearchResults(query),
  { wait: 500 }
)

// Хук на основе состояния для реактивного управления
const [instantState, setInstantState] = useState('')
const [debouncedState, setDebouncedState] = useDebouncedValue(
  instantState, // Значение для дебаунсинга
  { wait: 500 }
)
```

#### Solid

```tsx
import { createDebouncer, createDebouncedSignal } from '@tanstack/solid-pacer'

// Низкоуровневый хук для полного контроля
const debouncer = createDebouncer(
  (value: string) => saveToDatabase(value),
  { wait: 500 }
)

// Хук на основе сигналов для управления состоянием
const [searchTerm, setSearchTerm, debouncer] = createDebouncedSignal('', {
  wait: 500,
  onExecute: (debouncer) => {
    console.log('Всего выполнений:', debouncer.getExecutionCount())
  }
})
```
