---
source-updated-at: '2025-05-08T02:24:20.000Z'
translation-updated-at: '2025-05-08T06:02:11.996Z'
title: Руководство по дебаунсингу
id: debouncing
---
# Руководство по Дебаунсингу (Debouncing)

Ограничение частоты (Rate Limiting), Троттлинг (Throttling) и Дебаунсинг (Debouncing) — это три различных подхода к управлению частотой выполнения функций. Каждая техника по-разному блокирует выполнение, делая их "потерянными" (lossy) — это означает, что некоторые вызовы функций не будут выполнены, если они запрашиваются слишком часто. Понимание, когда использовать каждый подход, критически важно для создания производительных и надежных приложений. В этом руководстве рассматриваются концепции Дебаунсинга в TanStack Pacer.

## Концепция Дебаунсинга (Debouncing)

Дебаунсинг — это техника, которая откладывает выполнение функции до тех пор, пока не пройдет указанный период бездействия. В отличие от ограничения частоты (rate limiting), которое допускает всплески выполнения до определенного предела, или троттлинга (throttling), который обеспечивает равномерно распределенные выполнения, дебаунсинг объединяет несколько быстрых вызовов функции в одно выполнение, которое происходит только после остановки вызовов. Это делает дебаунсинг идеальным для обработки всплесков событий, где важно только конечное состояние после завершения активности.

### Визуализация Дебаунсинга

```text
Debouncing (wait: 3 ticks)
Timeline: [1 second per tick]
Calls:        ⬇️  ⬇️  ⬇️  ⬇️  ⬇️     ⬇️  ⬇️  ⬇️  ⬇️               ⬇️  ⬇️
Executed:     ❌  ❌  ❌  ❌  ❌     ❌  ❌  ❌  ⏳   ->   ✅     ❌  ⏳   ->    ✅
             [=================================================================]
                                                        ^ Выполняется здесь после
                                                         3 тиков без вызовов

             [Всплеск вызовов]     [Дополнительные вызовы]   [Ожидание]      [Новый всплеск]
             Нет выполнения        Сбрасывает таймер         [Отложенное выполнение]  [Ожидание] [Отложенное выполнение]
```

### Когда использовать Дебаунсинг

Дебаунсинг особенно эффективен, когда вы хотите дождаться "паузы" в активности перед выполнением действия. Это делает его идеальным для обработки пользовательского ввода или других быстро повторяющихся событий, где важно только конечное состояние.

Распространенные сценарии использования:
- Поля поиска, где нужно дождаться завершения ввода пользователем
- Валидация форм, которая не должна выполняться при каждом нажатии клавиши
- Вычисления при изменении размера окна, которые требуют значительных ресурсов
- Автосохранение черновиков при редактировании контента
- API-вызовы, которые должны выполняться только после завершения активности пользователя
- Любой сценарий, где важно только конечное значение после быстрых изменений

### Когда не следует использовать Дебаунсинг

Дебаунсинг может быть не лучшим выбором, когда:
- Нужно гарантированное выполнение в определенный период времени (используйте [троттлинг](../guides/throttling))
- Нельзя пропускать ни одного выполнения (используйте [очередь (queueing)](../guides/queueing))

## Дебаунсинг в TanStack Pacer

TanStack Pacer предоставляет как синхронный, так и асинхронный дебаунсинг через классы `Debouncer` и `AsyncDebouncer` соответственно (и соответствующие функции `debounce` и `asyncDebounce`).

### Базовое использование с `debounce`

Функция `debounce` — это самый простой способ добавить дебаунсинг к любой функции:

```ts
import { debounce } from '@tanstack/pacer'

// Дебаунсинг поля поиска для ожидания завершения ввода пользователем
const debouncedSearch = debounce(
  (searchTerm: string) => performSearch(searchTerm),
  {
    wait: 500, // Ждать 500 мс после последнего нажатия клавиши
  }
)

searchInput.addEventListener('input', (e) => {
  debouncedSearch(e.target.value)
})
```

### Расширенное использование с классом `Debouncer`

Для большего контроля над поведением дебаунсинга можно использовать класс `Debouncer` напрямую:

```ts
import { Debouncer } from '@tanstack/pacer'

const searchDebouncer = new Debouncer(
  (searchTerm: string) => performSearch(searchTerm),
  { wait: 500 }
)

// Получение информации о текущем состоянии
console.log(searchDebouncer.getExecutionCount()) // Количество успешных выполнений
console.log(searchDebouncer.getIsPending()) // Есть ли ожидающий вызов

// Динамическое обновление параметров
searchDebouncer.setOptions({ wait: 1000 }) // Увеличение времени ожидания

// Отмена ожидающего выполнения
searchDebouncer.cancel()
```

### Выполнение на переднем и заднем крае (Leading и Trailing)

Синхронный дебаунсер поддерживает выполнение как на переднем (leading), так и на заднем (trailing) крае:

```ts
const debouncedFn = debounce(fn, {
  wait: 500,
  leading: true,   // Выполнить при первом вызове
  trailing: true,  // Выполнить после периода ожидания
})
```

- `leading: true` — Функция выполняется сразу при первом вызове
- `leading: false` (по умолчанию) — Первый вызов запускает таймер ожидания
- `trailing: true` (по умолчанию) — Функция выполняется после периода ожидания
- `trailing: false` — Нет выполнения после периода ожидания

Распространенные паттерны:
- `{ leading: false, trailing: true }` — По умолчанию, выполнение после ожидания
- `{ leading: true, trailing: false }` — Выполнение сразу, игнорирование последующих вызовов
- `{ leading: true, trailing: true }` — Выполнение как при первом вызове, так и после ожидания

### Максимальное время ожидания (Max Wait Time)

Дебаунсер TanStack Pacer намеренно не имеет опции `maxWait`, в отличие от других библиотек дебаунсинга. Если нужно, чтобы выполнения происходили в более распределенный период времени, рассмотрите использование техники [троттлинга](../guides/throttling).

### Включение/отключение

Класс `Debouncer` поддерживает включение/отключение через опцию `enabled`. Используя метод `setOptions`, можно включать/отключать дебаунсер в любое время:

```ts
const debouncer = new Debouncer(fn, { wait: 500, enabled: false }) // Отключен по умолчанию
debouncer.setOptions({ enabled: true }) // Включить в любое время
```

Если используется адаптер для фреймворка, где параметры дебаунсера реактивны, можно установить опцию `enabled` в условное значение для динамического включения/отключения дебаунсера:

```ts
// Пример для React
const debouncer = useDebouncer(
  setSearch, 
  { wait: 500, enabled: searchInput.value.length > 3 } // Включение/отключение на основе длины ввода, ЕСЛИ используется адаптер фреймворка, поддерживающий реактивные параметры
)
```

Однако, если используется функция `debounce` или класс `Debouncer` напрямую, необходимо использовать метод `setOptions` для изменения опции `enabled`, так как передаваемые параметры фактически передаются в конструктор класса `Debouncer`.

```ts
// Пример для Solid
const debouncer = new Debouncer(fn, { wait: 500, enabled: false }) // Отключен по умолчанию
createEffect(() => {
  debouncer.setOptions({ enabled: search().length > 3 }) // Включение/отключение на основе длины ввода
})
```

### Опции обратных вызовов (Callback Options)

Как синхронный, так и асинхронный дебаунсеры поддерживают опции обратных вызовов для обработки различных аспектов жизненного цикла дебаунсинга.

#### Обратные вызовы синхронного дебаунсера

Синхронный `Debouncer` поддерживает следующий обратный вызов:

```ts
const debouncer = new Debouncer(fn, {
  wait: 500,
  onExecute: (debouncer) => {
    // Вызывается после каждого успешного выполнения
    console.log('Функция выполнена', debouncer.getExecutionCount())
  }
})
```

Обратный вызов `onExecute` вызывается после каждого успешного выполнения дебаунсированной функции, что полезно для отслеживания выполнений, обновления состояния UI или выполнения операций очистки.

#### Обратные вызовы асинхронного дебаунсера

Асинхронный `AsyncDebouncer` имеет другой набор обратных вызовов по сравнению с синхронной версией.

```ts
const asyncDebouncer = new AsyncDebouncer(async (value) => {
  await saveToAPI(value)
}, {
  wait: 500,
  onSuccess: (result, debouncer) => {
    // Вызывается после каждого успешного выполнения
    console.log('Асинхронная функция выполнена', debouncer.getSuccessCount())
  },
  onSettled: (debouncer) => {
    // Вызывается после каждой попытки выполнения
    console.log('Асинхронная функция завершена', debouncer.getSettledCount())
  },
  onError: (error) => {
    // Вызывается, если асинхронная функция выбрасывает ошибку
    console.error('Асинхронная функция завершилась с ошибкой:', error)
  }
})
```

Обратный вызов `onSuccess` вызывается после каждого успешного выполнения дебаунсированной функции, а `onError` вызывается, если асинхронная функция выбрасывает ошибку. `onSettled` вызывается после каждой попытки выполнения, независимо от успеха или ошибки. Эти обратные вызовы особенно полезны для отслеживания количества выполнений, обновления состояния UI, обработки ошибок, выполнения операций очистки и логирования метрик выполнения.

### Асинхронный дебаунсинг

Асинхронный дебаунсер предоставляет мощный способ обработки асинхронных операций с дебаунсингом, предлагая несколько ключевых преимуществ по сравнению с синхронной версией. В то время как синхронный дебаунсер отлично подходит для событий UI и немедленной обратной связи, асинхронная версия специально разработана для обработки API-вызовов, операций с базой данных и других асинхронных задач.

#### Ключевые отличия от синхронного дебаунсинга

1. **Обработка возвращаемого значения**
В отличие от синхронного дебаунсера, который возвращает void, асинхронная версия позволяет захватывать и использовать возвращаемое значение из вашей дебаунсированной функции. Это особенно полезно, когда нужно работать с результатами API-вызовов или других асинхронных операций. Метод `maybeExecute` возвращает Promise, который разрешается с возвращаемым значением функции, позволяя ожидать результат и обрабатывать его соответствующим образом.

2. **Разные обратные вызовы**
`AsyncDebouncer` поддерживает следующие обратные вызовы вместо только `onExecute` в синхронной версии:
- `onSuccess`: Вызывается после каждого успешного выполнения, предоставляя экземпляр дебаунсера
- `onSettled`: Вызывается после каждого выполнения, предоставляя экземпляр дебаунсера
- `onError`: Вызывается, если асинхронная функция выбрасывает ошибку, предоставляя как ошибку, так и экземпляр дебаунсера

3. **Последовательное выполнение**
Поскольку метод `maybeExecute` дебаунсера возвращает Promise, можно ожидать каждое выполнение перед началом следующего. Это дает контроль над порядком выполнения и гарантирует, что каждый вызов обрабатывает самые актуальные данные. Это особенно полезно при работе с операциями, которые зависят от результатов предыдущих вызовов, или когда критически важна согласованность данных.

Например, если обновляется профиль пользователя и затем сразу же запрашиваются обновленные данные, можно ожидать операцию обновления перед началом запроса:

#### Базовый пример использования

Вот базовый пример, показывающий, как использовать асинхронный дебаунсер для операции поиска:

```ts
const debouncedSearch = asyncDebounce(
  async (searchTerm: string) => {
    const results = await fetchSearchResults(searchTerm)
    return results
  },
  {
    wait: 500,
    onSuccess: (results, debouncer) => {
      console.log('Поиск успешен:', results)
    },
    onError: (error, debouncer) => {
      console.error('Поиск завершился ошибкой:', error)
    }
  }
)

// Использование
const results = await debouncedSearch('query')
```

### Адаптеры для фреймворков

Каждый адаптер для фреймворка предоставляет хуки, которые расширяют базовую функциональность дебаунсинга для интеграции с системой управления состоянием фреймворка. Для каждого фреймворка доступны хуки, такие как `createDebouncer`, `useDebouncedCallback`, `useDebouncedState` или `useDebouncedValue`.

Вот несколько примеров:

#### React

```tsx
import { useDebouncer, useDebouncedCallback, useDebouncedValue } from '@tanstack/react-pacer'

// Низкоуровневый хук для полного контроля
const debouncer = useDebouncer(
  (value: string) => saveToDatabase(value),
  { wait: 500 }
)

// Простой хук обратного вызова для базовых сценариев
const handleSearch = useDebouncedCallback(
  (query: string) => fetchSearchResults(query),
  { wait: 500 }
)

// Хук на основе состояния для реактивного управления состоянием
const [instantState, setInstantState] = useState('')
const [debouncedValue] = useDebouncedValue(
  instantState, // Значение для дебаунсинга
  { wait: 500 }
)
```

#### Solid

```tsx
import { createDebouncer, createDebouncedSignal } from '@tanstack/solid-pacer'

// Низкоуровневый хук для полного контроля
const debouncer = createDebouncer(
  (value: string) => saveToDatabase(value),
  { wait: 500 }
)

// Хук на основе сигнала для управления состоянием
const [searchTerm, setSearchTerm, debouncer] = createDebouncedSignal('', {
  wait: 500,
  onExecute: (debouncer) => {
    console.log('Всего выполнений:', debouncer.getExecutionCount())
  }
})
```
