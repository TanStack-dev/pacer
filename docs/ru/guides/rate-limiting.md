---
source-updated-at: '2025-05-08T02:24:20.000Z'
translation-updated-at: '2025-05-08T06:02:32.139Z'
title: Руководство по ограничению частоты
id: rate-limiting
---
# Руководство по ограничению частоты запросов (Rate Limiting)

Ограничение частоты запросов (Rate Limiting), регулирование (Throttling) и устранение дребезга (Debouncing) — это три различных подхода к контролю частоты выполнения функций. Каждый метод по-разному блокирует выполнение, делая их "потерянными" (lossy) — это означает, что некоторые вызовы функций не будут выполнены, если они запрашиваются слишком часто. Понимание, когда использовать каждый подход, крайне важно для создания производительных и надежных приложений. В этом руководстве рассматриваются концепции ограничения частоты запросов в TanStack Pacer.

> [!NOTE]
> TanStack Pacer в настоящее время является библиотекой только для фронтенда. Это утилиты для ограничения частоты запросов на стороне клиента.

## Концепция ограничения частоты запросов (Rate Limiting)

Ограничение частоты запросов (Rate Limiting) — это метод, который ограничивает частоту выполнения функции в течение определенного временного окна. Он особенно полезен в сценариях, где нужно предотвратить слишком частые вызовы функции, например, при обработке API-запросов или других вызовов внешних сервисов. Это наиболее *простой* подход, так как он позволяет выполнять вызовы пакетами до достижения квоты.

### Визуализация ограничения частоты запросов

```text
Rate Limiting (limit: 3 calls per window)
Timeline: [1 second per tick]
                                        Window 1                  |    Window 2            
Calls:        ⬇️     ⬇️     ⬇️     ⬇️     ⬇️                             ⬇️     ⬇️
Executed:     ✅     ✅     ✅     ❌     ❌                             ✅     ✅
             [=== 3 allowed ===][=== blocked until window ends ===][=== new window =======]
```

### Типы окон

TanStack Pacer поддерживает два типа окон для ограничения частоты запросов:

1. **Фиксированное окно (Fixed Window)** (по умолчанию)
   - Строгое окно, которое сбрасывается после завершения периода
   - Все выполнения в пределах окна учитываются в лимите
   - Окно полностью сбрасывается после периода
   - Может приводить к пакетному поведению на границах окон

2. **Скользящее окно (Sliding Window)**
   - Динамическое окно, позволяющее выполнять вызовы по мере истечения старых
   - Обеспечивает более равномерную частоту выполнения с течением времени
   - Лучше подходит для поддержания стабильного потока выполнений
   - Предотвращает пакетное поведение на границах окон

Вот визуализация ограничения частоты запросов со скользящим окном:

```text
Sliding Window Rate Limiting (limit: 3 calls per window)
Timeline: [1 second per tick]
                                        Window 1                  |    Window 2            
Calls:        ⬇️     ⬇️     ⬇️     ⬇️     ⬇️                             ⬇️     ⬇️
Executed:     ✅     ✅     ✅     ❌     ✅                             ✅     ✅
             [=== 3 allowed ===][=== oldest expires, new allowed ===][=== continues sliding =======]
```

Ключевое отличие заключается в том, что при скользящем окне, как только истекает срок самого старого выполнения, разрешается новое выполнение. Это создает более равномерный поток выполнений по сравнению с подходом фиксированного окна.

### Когда использовать ограничение частоты запросов

Ограничение частоты запросов особенно важно при работе с фронтенд-операциями, которые могут случайно перегрузить бэкенд-сервисы или вызвать проблемы с производительностью в браузере.

Распространенные сценарии использования:
- Предотвращение случайного спама API из-за быстрых действий пользователя (например, кликов по кнопке или отправки форм)
- Сценарии, где пакетное поведение допустимо, но требуется ограничить максимальную частоту
- Защита от случайных бесконечных циклов или рекурсивных операций

### Когда не использовать ограничение частоты запросов

Ограничение частоты запросов — это самый простой подход к контролю частоты выполнения функций. Он наименее гибкий и наиболее ограничительный из трех методов. Вместо него рассмотрите использование [регулирования (throttling)](../guides/throttling) или [устранения дребезга (debouncing)](../guides/debouncing) для более равномерного выполнения.

> [!TIP]
> В большинстве случаев вам, скорее всего, не нужно использовать "ограничение частоты запросов". Вместо этого рассмотрите [регулирование (throttling)](../guides/throttling) или [устранение дребезга (debouncing)](../guides/debouncing).

"Потерянная" природа ограничения частоты запросов также означает, что некоторые выполнения будут отклонены и потеряны. Это может быть проблемой, если нужно гарантировать, что все выполнения всегда успешны. Рассмотрите использование [очереди (queueing)](../guides/queueing), если требуется обеспечить, чтобы все выполнения были поставлены в очередь для выполнения, но с задержкой для замедления частоты выполнения.

## Ограничение частоты запросов в TanStack Pacer

TanStack Pacer предоставляет синхронное и асинхронное ограничение частоты запросов через классы `RateLimiter` и `AsyncRateLimiter` соответственно (и соответствующие функции `rateLimit` и `asyncRateLimit`).

### Базовое использование с `rateLimit`

Функция `rateLimit` — это самый простой способ добавить ограничение частоты запросов к любой функции. Она идеально подходит для большинства случаев, когда нужно просто установить лимит.

```ts
import { rateLimit } from '@tanstack/pacer'

// Ограничение API-запросов до 5 в минуту
const rateLimitedApi = rateLimit(
  (id: string) => fetchUserData(id),
  {
    limit: 5,
    window: 60 * 1000, // 1 минута в миллисекундах
    windowType: 'fixed', // по умолчанию
    onReject: (rateLimiter) => {
      console.log(`Превышен лимит запросов. Попробуйте снова через ${rateLimiter.getMsUntilNextWindow()}мс`)
    }
  }
)

// Первые 5 вызовов выполнятся немедленно
rateLimitedApi('user-1') // ✅ Выполняется
rateLimitedApi('user-2') // ✅ Выполняется
rateLimitedApi('user-3') // ✅ Выполняется
rateLimitedApi('user-4') // ✅ Выполняется
rateLimitedApi('user-5') // ✅ Выполняется
rateLimitedApi('user-6') // ❌ Отклоняется до сброса окна
```

### Расширенное использование с классом `RateLimiter`

Для более сложных сценариев, где требуется дополнительный контроль над поведением ограничения частоты запросов, можно использовать класс `RateLimiter` напрямую. Это дает доступ к дополнительным методам и информации о состоянии.

```ts
import { RateLimiter } from '@tanstack/pacer'

// Создание экземпляра ограничителя
const limiter = new RateLimiter(
  (id: string) => fetchUserData(id),
  {
    limit: 5,
    window: 60 * 1000,
    onExecute: (rateLimiter) => {
      console.log('Функция выполнена', rateLimiter.getExecutionCount())
    },
    onReject: (rateLimiter) => {
      console.log(`Превышен лимит запросов. Попробуйте снова через ${rateLimiter.getMsUntilNextWindow()}мс`)
    }
  }
)

// Получение информации о текущем состоянии
console.log(limiter.getRemainingInWindow()) // Количество оставшихся вызовов в текущем окне
console.log(limiter.getExecutionCount()) // Общее количество успешных выполнений
console.log(limiter.getRejectionCount()) // Общее количество отклоненных выполнений

// Попытка выполнения (возвращает boolean, указывающий на успех)
limiter.maybeExecute('user-1')

// Динамическое обновление параметров
limiter.setOptions({ limit: 10 }) // Увеличение лимита

// Сброс всех счетчиков и состояния
limiter.reset()
```

### Включение/отключение

Класс `RateLimiter` поддерживает включение/отключение через опцию `enabled`. Используя метод `setOptions`, можно включать/отключать ограничитель в любое время:

> [!NOTE]
> Опция `enabled` включает/отключает фактическое выполнение функции. Отключение ограничителя частоты запросов не отключает сам механизм ограничения, а только предотвращает выполнение функции.

```ts
const limiter = new RateLimiter(fn, { 
  limit: 5, 
  window: 1000,
  enabled: false // Отключено по умолчанию
})
limiter.setOptions({ enabled: true }) // Включить в любое время
```

Если используется адаптер для фреймворка, где параметры ограничителя реактивны, можно установить опцию `enabled` в условное значение для динамического включения/отключения ограничителя. Однако при использовании функции `rateLimit` или класса `RateLimiter` напрямую необходимо использовать метод `setOptions` для изменения опции `enabled`, так как переданные параметры фактически передаются в конструктор класса `RateLimiter`.

### Опции обратных вызовов

Как синхронные, так и асинхронные ограничители поддерживают опции обратных вызовов для обработки различных аспектов жизненного цикла ограничения частоты запросов:

#### Обратные вызовы синхронного ограничителя

Синхронный `RateLimiter` поддерживает следующие обратные вызовы:

```ts
const limiter = new RateLimiter(fn, {
  limit: 5,
  window: 1000,
  onExecute: (rateLimiter) => {
    // Вызывается после каждого успешного выполнения
    console.log('Функция выполнена', rateLimiter.getExecutionCount())
  },
  onReject: (rateLimiter) => {
    // Вызывается при отклонении выполнения
    console.log(`Превышен лимит запросов. Попробуйте снова через ${rateLimiter.getMsUntilNextWindow()}мс`)
  }
})
```

Обратный вызов `onExecute` вызывается после каждого успешного выполнения ограниченной функции, а `onReject` — при отклонении выполнения из-за ограничения частоты запросов. Эти обратные вызовы полезны для отслеживания выполнений, обновления состояния UI или предоставления обратной связи пользователям.

#### Обратные вызовы асинхронного ограничителя

Асинхронный `AsyncRateLimiter` поддерживает дополнительные обратные вызовы для обработки ошибок:

```ts
const asyncLimiter = new AsyncRateLimiter(async (id) => {
  await saveToAPI(id)
}, {
  limit: 5,
  window: 1000,
  onExecute: (rateLimiter) => {
    // Вызывается после каждого успешного выполнения
    console.log('Асинхронная функция выполнена', rateLimiter.getExecutionCount())
  },
  onReject: (rateLimiter) => {
    // Вызывается при отклонении выполнения
    console.log(`Превышен лимит запросов. Попробуйте снова через ${rateLimiter.getMsUntilNextWindow()}мс`)
  },
  onError: (error) => {
    // Вызывается, если асинхронная функция выбрасывает ошибку
    console.error('Асинхронная функция завершилась ошибкой:', error)
  }
})
```

Обратные вызовы `onExecute` и `onReject` работают так же, как в синхронном ограничителе, а `onError` позволяет обрабатывать ошибки без прерывания цепочки ограничения частоты запросов. Эти обратные вызовы особенно полезны для отслеживания количества выполнений, обновления состояния UI, обработки ошибок и предоставления обратной связи пользователям.

### Асинхронное ограничение частоты запросов

Асинхронный ограничитель предоставляет мощный способ обработки асинхронных операций с ограничением частоты запросов, предлагая несколько ключевых преимуществ по сравнению с синхронной версией. В то время как синхронный ограничитель отлично подходит для событий UI и немедленной обратной связи, асинхронная версия специально разработана для обработки API-вызовов, операций с базой данных и других асинхронных задач.

#### Ключевые отличия от синхронного ограничения частоты запросов

1. **Обработка возвращаемого значения**
В отличие от синхронного ограничителя, который возвращает boolean, указывающий на успех, асинхронная версия позволяет захватывать и использовать возвращаемое значение из ограниченной функции. Это особенно полезно при работе с результатами API-вызовов или других асинхронных операций. Метод `maybeExecute` возвращает Promise, который разрешается с возвращаемым значением функции, позволяя ожидать результат и обрабатывать его соответствующим образом.

2. **Разные обратные вызовы**
`AsyncRateLimiter` поддерживает следующие обратные вызовы вместо только `onExecute` в синхронной версии:
- `onSuccess`: Вызывается после каждого успешного выполнения, предоставляя экземпляр ограничителя
- `onSettled`: Вызывается после каждого выполнения, предоставляя экземпляр ограничителя
- `onError`: Вызывается, если асинхронная функция выбрасывает ошибку, предоставляя как ошибку, так и экземпляр ограничителя

Как асинхронные, так и синхронные ограничители поддерживают обратный вызов `onReject` для обработки заблокированных выполнений.

3. **Последовательное выполнение**
Поскольку метод `maybeExecute` ограничителя возвращает Promise, можно ожидать каждое выполнение перед началом следующего. Это дает контроль над порядком выполнения и гарантирует, что каждый вызов обрабатывает самые актуальные данные. Это особенно полезно при работе с операциями, которые зависят от результатов предыдущих вызовов, или когда критически важна согласованность данных.

Например, если обновляется профиль пользователя и затем сразу же запрашиваются обновленные данные, можно ожидать операцию обновления перед началом запроса:

#### Пример базового использования

Вот простой пример использования асинхронного ограничителя для API-операции:

```ts
const rateLimitedApi = asyncRateLimit(
  async (id: string) => {
    const response = await fetch(`/api/data/${id}`)
    return response.json()
  },
  {
    limit: 5,
    window: 1000,
    onExecute: (limiter) => {
      console.log('API-вызов успешен:', limiter.getExecutionCount())
    },
    onReject: (limiter) => {
      console.log(`Превышен лимит запросов. Попробуйте снова через ${limiter.getMsUntilNextWindow()}мс`)
    },
    onError: (error, limiter) => {
      console.error('API-вызов завершился ошибкой:', error)
    }
  }
)

// Использование
const result = await rateLimitedApi('123')
```

### Адаптеры для фреймворков

Каждый адаптер для фреймворка предоставляет хуки, которые расширяют базовую функциональность ограничения частоты запросов для интеграции с системой управления состоянием фреймворка. Для каждого фреймворка доступны хуки, такие как `createRateLimiter`, `useRateLimitedCallback`, `useRateLimitedState` или `useRateLimitedValue`.

Вот несколько примеров:

#### React

```tsx
import { useRateLimiter, useRateLimitedCallback, useRateLimitedValue } from '@tanstack/react-pacer'

// Низкоуровневый хук для полного контроля
const limiter = useRateLimiter(
  (id: string) => fetchUserData(id),
  { limit: 5, window: 1000 }
)

// Простой хук обратного вызова для базовых случаев
const handleFetch = useRateLimitedCallback(
  (id: string) => fetchUserData(id),
  { limit: 5, window: 1000 }
)

// Хук на основе состояния для реактивного управления состоянием
const [instantState, setInstantState] = useState('')
const [rateLimitedValue] = useRateLimitedValue(
  instantState, // Значение для ограничения частоты
  { limit: 5, window: 1000 }
)
```

#### Solid

```tsx
import { createRateLimiter, createRateLimitedSignal } from '@tanstack/solid-pacer'

// Низкоуровневый хук для полного контроля
const limiter = createRateLimiter(
  (id: string) => fetchUserData(id),
  { limit: 5, window: 1000 }
)

// Хук на основе сигнала для управления состоянием
const [value, setValue, limiter] = createRateLimitedSignal('', {
  limit: 5,
  window:
