---
source-updated-at: '2025-05-05T07:34:55.000Z'
translation-updated-at: '2025-05-06T23:19:56.788Z'
title: Руководство по ограничению частоты
id: rate-limiting
---
# Руководство по ограничению частоты запросов (Rate Limiting)

Ограничение частоты запросов (Rate Limiting), регулирование (Throttling) и устранение дребезга (Debouncing) — это три различных подхода к контролю частоты выполнения функций. Каждая методика блокирует выполнение по-своему, делая их "потерянными" (lossy) — это означает, что некоторые вызовы функций не будут выполнены, если они запрашиваются слишком часто. Понимание, когда использовать каждый подход, критически важно для создания производительных и надежных приложений. В этом руководстве рассматриваются концепции ограничения частоты запросов в TanStack Pacer.

> [!NOTE]
> TanStack Pacer в настоящее время является только фронтенд-библиотекой. Это утилиты для ограничения частоты запросов на стороне клиента.

## Концепция ограничения частоты запросов

Ограничение частоты запросов (Rate Limiting) — это методика, которая ограничивает частоту выполнения функции в определенном временном окне. Она особенно полезна в сценариях, когда нужно предотвратить слишком частые вызовы функции, например, при обработке API-запросов или других вызовов внешних сервисов. Это наиболее *наивный* подход, так как он позволяет выполнять вызовы пакетами до исчерпания квоты.

### Визуализация ограничения частоты запросов

```text
Rate Limiting (limit: 3 calls per window)
Timeline: [1 second per tick]
                                        Window 1                  |    Window 2            
Calls:        ⬇️     ⬇️     ⬇️     ⬇️     ⬇️                             ⬇️     ⬇️
Executed:     ✅     ✅     ✅     ❌     ❌                             ✅     ✅
             [=== 3 allowed ===][=== blocked until window ends ===][=== new window =======]
```

### Когда использовать ограничение частоты запросов

Ограничение частоты запросов особенно важно при работе с фронтенд-операциями, которые могут случайно перегрузить бэкенд-сервисы или вызвать проблемы с производительностью в браузере.

Распространенные сценарии использования:
- Предотвращение случайного спама API из-за быстрых действий пользователя (например, кликов по кнопке или отправки форм)
- Сценарии, где допустимо пакетное поведение, но нужно ограничить максимальную частоту
- Защита от случайных бесконечных циклов или рекурсивных операций

### Когда не следует использовать ограничение частоты запросов

Ограничение частоты запросов — это наиболее наивный подход к контролю частоты выполнения функций. Он наименее гибкий и наиболее ограничительный среди трех методик. Рассмотрите использование [регулирования (throttling)](../guides/throttling) или [устранения дребезга (debouncing)](../guides/debouncing) для более равномерного распределения выполнения.

> [!TIP]
> В большинстве случаев вам, скорее всего, не нужно использовать "ограничение частоты запросов". Рассмотрите использование [регулирования (throttling)](../guides/throttling) или [устранения дребезга (debouncing)](../guides/debouncing) вместо этого.

"Потерянная" природа ограничения частоты запросов также означает, что некоторые выполнения будут отклонены и потеряны. Это может быть проблемой, если нужно гарантировать успешность всех выполнений. Рассмотрите использование [очереди (queueing)](../guides/queueing), если необходимо обеспечить, чтобы все выполнения были поставлены в очередь для выполнения, но с задержкой для замедления частоты выполнения.

## Ограничение частоты запросов в TanStack Pacer

TanStack Pacer предоставляет как синхронное, так и асинхронное ограничение частоты запросов через классы `RateLimiter` и `AsyncRateLimiter` соответственно (и соответствующие функции `rateLimit` и `asyncRateLimit`).

### Базовое использование с `rateLimit`

Функция `rateLimit` — это самый простой способ добавить ограничение частоты запросов к любой функции. Она идеально подходит для большинства случаев, когда нужно просто установить лимит.

```ts
import { rateLimit } from '@tanstack/pacer'

// Ограничение API-запросов до 5 в минуту
const rateLimitedApi = rateLimit(
  (id: string) => fetchUserData(id),
  {
    limit: 5,
    window: 60 * 1000, // 1 минута в миллисекундах
    onReject: (rateLimiter) => {
      console.log(`Превышен лимит запросов. Попробуйте снова через ${rateLimiter.getMsUntilNextWindow()}мс`)
    }
  }
)

// Первые 5 вызовов выполнятся немедленно
rateLimitedApi('user-1') // ✅ Выполняется
rateLimitedApi('user-2') // ✅ Выполняется
rateLimitedApi('user-3') // ✅ Выполняется
rateLimitedApi('user-4') // ✅ Выполняется
rateLimitedApi('user-5') // ✅ Выполняется
rateLimitedApi('user-6') // ❌ Отклоняется до сброса окна
```

### Продвинутое использование с классом `RateLimiter`

Для более сложных сценариев, где требуется дополнительный контроль над поведением ограничения частоты запросов, можно использовать класс `RateLimiter` напрямую. Это дает доступ к дополнительным методам и информации о состоянии.

```ts
import { RateLimiter } from '@tanstack/pacer'

// Создание экземпляра ограничителя частоты запросов
const limiter = new RateLimiter(
  (id: string) => fetchUserData(id),
  {
    limit: 5,
    window: 60 * 1000,
    onExecute: (rateLimiter) => {
      console.log('Функция выполнена', rateLimiter.getExecutionCount())
    },
    onReject: (rateLimiter) => {
      console.log(`Превышен лимит запросов. Попробуйте снова через ${rateLimiter.getMsUntilNextWindow()}мс`)
    }
  }
)

// Получение информации о текущем состоянии
console.log(limiter.getRemainingInWindow()) // Количество оставшихся вызовов в текущем окне
console.log(limiter.getExecutionCount()) // Общее количество успешных выполнений
console.log(limiter.getRejectionCount()) // Общее количество отклоненных выполнений

// Попытка выполнения (возвращает boolean, указывающий на успех)
limiter.maybeExecute('user-1')

// Динамическое обновление параметров
limiter.setOptions({ limit: 10 }) // Увеличение лимита

// Сброс всех счетчиков и состояния
limiter.reset()
```

### Включение/отключение

Класс `RateLimiter` поддерживает включение/отключение через параметр `enabled`. Используя метод `setOptions`, можно включать/отключать ограничитель частоты запросов в любое время:

```ts
const limiter = new RateLimiter(fn, { 
  limit: 5, 
  window: 1000,
  enabled: false // Отключено по умолчанию
})
limiter.setOptions({ enabled: true }) // Включить в любое время
```

Если используется адаптер для фреймворка, где параметры ограничителя реактивны, можно установить параметр `enabled` в условное значение для динамического включения/отключения ограничителя. Однако при использовании функции `rateLimit` или класса `RateLimiter` напрямую необходимо использовать метод `setOptions` для изменения параметра `enabled`, так как передаваемые параметры фактически передаются в конструктор класса `RateLimiter`.

### Параметры обратных вызовов

Как синхронные, так и асинхронные ограничители частоты запросов поддерживают параметры обратных вызовов для обработки различных аспектов жизненного цикла ограничения частоты запросов:

#### Обратные вызовы синхронного ограничителя частоты запросов

Синхронный `RateLimiter` поддерживает следующие обратные вызовы:

```ts
const limiter = new RateLimiter(fn, {
  limit: 5,
  window: 1000,
  onExecute: (rateLimiter) => {
    // Вызывается после каждого успешного выполнения
    console.log('Функция выполнена', rateLimiter.getExecutionCount())
  },
  onReject: (rateLimiter) => {
    // Вызывается при отклонении выполнения
    console.log(`Превышен лимит запросов. Попробуйте снова через ${rateLimiter.getMsUntilNextWindow()}мс`)
  }
})
```

Обратный вызов `onExecute` вызывается после каждого успешного выполнения ограниченной функции, а `onReject` — при отклонении выполнения из-за ограничения частоты запросов. Эти обратные вызовы полезны для отслеживания выполнений, обновления состояния UI или предоставления обратной связи пользователям.

#### Обратные вызовы асинхронного ограничителя частоты запросов

Асинхронный `AsyncRateLimiter` поддерживает дополнительные обратные вызовы для обработки ошибок:

```ts
const asyncLimiter = new AsyncRateLimiter(async (id) => {
  await saveToAPI(id)
}, {
  limit: 5,
  window: 1000,
  onExecute: (rateLimiter) => {
    // Вызывается после каждого успешного выполнения
    console.log('Асинхронная функция выполнена', rateLimiter.getExecutionCount())
  },
  onReject: (rateLimiter) => {
    // Вызывается при отклонении выполнения
    console.log(`Превышен лимит запросов. Попробуйте снова через ${rateLimiter.getMsUntilNextWindow()}мс`)
  },
  onError: (error) => {
    // Вызывается при возникновении ошибки в асинхронной функции
    console.error('Ошибка асинхронной функции:', error)
  }
})
```

Обратные вызовы `onExecute` и `onReject` работают так же, как и в синхронном ограничителе, а `onError` позволяет обрабатывать ошибки без прерывания цепочки ограничения частоты запросов. Эти обратные вызовы особенно полезны для отслеживания количества выполнений, обновления состояния UI, обработки ошибок и предоставления обратной связи пользователям.

### Асинхронное ограничение частоты запросов

Асинхронный ограничитель частоты запросов предоставляет мощный способ обработки асинхронных операций с ограничением частоты, предлагая несколько ключевых преимуществ по сравнению с синхронной версией. В то время как синхронный ограничитель отлично подходит для событий UI и немедленной обратной связи, асинхронная версия специально разработана для обработки API-вызовов, операций с базой данных и других асинхронных задач.

#### Ключевые отличия от синхронного ограничения частоты запросов

1. **Обработка возвращаемых значений**
В отличие от синхронного ограничителя, который возвращает boolean, указывающий на успех, асинхронная версия позволяет захватывать и использовать возвращаемое значение из ограниченной функции. Это особенно полезно при работе с результатами API-вызовов или других асинхронных операций. Метод `maybeExecute` возвращает Promise, который разрешается с возвращаемым значением функции, позволяя ожидать результат и обрабатывать его соответствующим образом.

2. **Улучшенная система обратных вызовов**
Асинхронный ограничитель частоты запросов предоставляет более сложную систему обратных вызовов по сравнению с синхронной версией. Эта система включает:
- `onExecute`: Вызывается после каждого успешного выполнения, предоставляя экземпляр ограничителя
- `onReject`: Вызывается при отклонении выполнения из-за ограничения частоты запросов, предоставляя экземпляр ограничителя
- `onError`: Вызывается при возникновении ошибки в асинхронной функции, предоставляя как ошибку, так и экземпляр ограничителя

3. **Отслеживание выполнений**
Асинхронный ограничитель частоты запросов предоставляет комплексное отслеживание выполнений через несколько методов:
- `getExecutionCount()`: Количество успешных выполнений
- `getRejectionCount()`: Количество отклоненных выполнений
- `getRemainingInWindow()`: Количество оставшихся выполнений в текущем окне
- `getMsUntilNextWindow()`: Миллисекунды до начала следующего окна

4. **Последовательное выполнение**
Асинхронный ограничитель частоты запросов гарантирует, что последующие выполнения ждут завершения предыдущего вызова перед началом. Это предотвращает выполнение в неправильном порядке и гарантирует, что каждый вызов обрабатывает самые актуальные данные. Это особенно важно при работе с операциями, которые зависят от результатов предыдущих вызовов, или когда критически важна согласованность данных.

Например, если вы обновляете профиль пользователя и затем сразу же получаете обновленные данные, асинхронный ограничитель частоты запросов гарантирует, что операция получения ждет завершения обновления, предотвращая состояния гонки, когда могут быть получены устаревшие данные.

#### Пример базового использования

Вот базовый пример использования асинхронного ограничителя частоты запросов для API-операции:

```ts
const rateLimitedApi = asyncRateLimit(
  async (id: string) => {
    const response = await fetch(`/api/data/${id}`)
    return response.json()
  },
  {
    limit: 5,
    window: 1000,
    onExecute: (limiter) => {
      console.log('API-вызов успешен:', limiter.getExecutionCount())
    },
    onReject: (limiter) => {
      console.log(`Превышен лимит запросов. Попробуйте снова через ${limiter.getMsUntilNextWindow()}мс`)
    },
    onError: (error, limiter) => {
      console.error('Ошибка API-вызова:', error)
    }
  }
)

// Использование
const result = await rateLimitedApi('123')
```

#### Продвинутые паттерны

Асинхронный ограничитель частоты запросов можно комбинировать с различными паттернами для решения сложных задач:

1. **Интеграция с управлением состоянием**
При использовании асинхронного ограничителя с системами управления состоянием (такими как useState в React или createSignal в Solid) можно создавать мощные паттерны для обработки состояний загрузки, ошибок и обновления данных. Обратные вызовы ограничителя предоставляют идеальные хуки для обновления состояния UI на основе успеха или неудачи операций.

2. **Предотвращение состояний гонки**
Паттерн ограничения частоты запросов естественным образом предотвращает состояния гонки во многих сценариях. Когда несколько частей приложения пытаются обновить один и тот же ресурс одновременно, ограничитель гарантирует, что обновления происходят в пределах настроенных лимитов, при этом все еще предоставляя результаты всем вызывающим сторонам.

3. **Восстановление после ошибок**
Возможности обработки ошибок асинхронного ограничителя делают его идеальным для реализации логики повторных попыток и паттернов восстановления после ошибок. Можно использовать обратный вызов `onError` для реализации пользовательских стратегий обработки ошибок, таких как экспоненциальная задержка или механизмы резервного копирования.

### Адаптеры для фреймворков

Каждый адаптер для фреймворка предоставляет хуки, которые расширяют базовую функциональность ограничения частоты запросов для интеграции с системой управления состоянием фреймворка. Для каждого фреймворка доступны хуки, такие как `createRateLimiter`, `useRateLimitedCallback`, `useRateLimitedState` или `useRateLimitedValue`.

Вот несколько примеров:

#### React

```tsx
import { useRateLimiter, useRateLimitedCallback, useRateLimitedValue } from '@tanstack/react-pacer'

// Низкоуровневый хук для полного контроля
const limiter = useRateLimiter(
  (id: string) => fetchUserData(id),
  { limit: 5, window: 1000 }
)

// Простой хук обратного вызова для базовых случаев
const handleFetch = useRateLimitedCallback(
  (id: string) => fetchUserData(id),
  { limit: 5, window: 1000 }
)

// Хук на основе состояния для реактивного управления состоянием
const [instantState, setInstantState] = useState('')
const [rateLimitedValue] = useRateLimitedValue(
  instantState, // Значение для ограничения частоты запросов
  { limit: 5, window: 1000 }
)
```

#### Solid

```tsx
import { createRateLimiter, createRateLimitedSignal } from '@tanstack/solid-pacer'

// Низкоуровневый хук для полного контроля
const limiter = createRateLimiter(
  (id: string) => fetchUserData(id),
  { limit: 5, window: 1000 }
