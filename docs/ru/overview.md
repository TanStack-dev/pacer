---
source-updated-at: '2025-05-05T07:34:55.000Z'
translation-updated-at: '2025-05-06T23:18:08.631Z'
title: Обзор
id: overview
---
# Обзор

TanStack Pacer — это библиотека, предоставляющая высококачественные утилиты для управления временем выполнения функций в ваших приложениях. Хотя аналогичные инструменты существуют и в других местах, мы стремимся учесть все важные детали, включая ***типобезопасность (type-safety)***, ***tree-shaking*** и согласованный ***интуитивный API (intuitive API)***. Сосредоточившись на этих основах и сделав их доступными в ***независимом от фреймворков (framework agnostic)*** стиле, мы надеемся, что эти утилиты и паттерны станут более распространёнными в ваших приложениях. Правильное управление выполнением часто остаётся второстепенным при разработке приложений, что приводит к проблемам с производительностью, состоянию гонки (race conditions) и плохому пользовательскому опыту, которых можно было избежать. TanStack Pacer помогает вам правильно реализовать эти важные паттерны с самого начала!

> [!IMPORTANT]
> TanStack Pacer находится в стадии **альфа-тестирования**, и его API может измениться.
>
> Область применения этой библиотеки может расширяться, но мы стремимся сохранять размер бандла каждой отдельной утилиты небольшим и сфокусированным.

## Происхождение

Многие идеи (и код) для TanStack Pacer не являются новыми. Фактически, многие из этих утилит уже давно существуют в других библиотеках TanStack. Мы извлекли код из TanStack Query, Router, Form и даже из оригинальной библиотеки [Swimmer](https://github.com/tannerlinsley/swimmer) Таннера. Затем мы доработали эти утилиты, заполнили некоторые пробелы и выпустили их в виде отдельной библиотеки.

## Ключевые возможности

- **Дебаунсинг (Debouncing)**
  - Откладывание выполнения функций до окончания периода бездействия
  - Синхронные и асинхронные утилиты дебаунсинга с поддержкой промисов и обработкой ошибок
- **Троттлинг (Throttling)**
  - Ограничение частоты вызова функции
  - Синхронные и асинхронные утилиты троттлинга с поддержкой промисов и обработкой ошибок
- **Ограничение частоты (Rate Limiting)**
  - Ограничение частоты вызова функции
  - Синхронные и асинхронные утилиты ограничения частоты с поддержкой промисов и обработкой ошибок
- **Очереди (Queuing)**
  - Постановка функций в очередь для выполнения в определённом порядке
  - Выбор между реализациями FIFO, LIFO и приоритетной очереди
  - Управление скоростью обработки с настраиваемыми временами ожидания или ограничениями параллелизма
  - Управление выполнением очереди с возможностью запуска/остановки
  - Удаление элементов из очереди по истечении настраиваемого времени
- **Асинхронные и синхронные вариации**
  - Выбор между синхронными и асинхронными версиями каждой утилиты
  - Обеспечение однократного выполнения функций при необходимости в асинхронных вариациях утилит
  - Опциональная обработка ошибок, успешного завершения и завершения в целом для асинхронных вариаций
- **Утилиты сравнения**
  - Глубокие проверки равенства между значениями
  - Создание пользовательской логики сравнения для специфических нужд
- **Удобные хуки**
  - Сокращение шаблонного кода с помощью предустановленных хуков, таких как `useDebouncedCallback`, `useThrottledValue`, `useQueuedState` и других.
  - Несколько уровней абстракции на выбор в зависимости от вашего случая использования.
  - Работает со стандартными решениями для управления состоянием в каждом фреймворке или с любой пользовательской библиотекой управления состоянием, которую вы предпочитаете.
- **Типобезопасность (Type Safety)**
  - Полная типобезопасность с TypeScript, гарантирующая, что ваши функции всегда будут вызываться с правильными аргументами
  - Дженерики для гибких и переиспользуемых утилит
- **Адаптеры для фреймворков**
  - React, Solid и другие
- **Tree Shaking**
  - Мы, конечно же, обеспечиваем правильную работу tree-shaking по умолчанию для ваших приложений, но также предоставляем дополнительные глубокие импорты для каждой утилиты, что упрощает их встраивание в ваши библиотеки без увеличения отчётов bundle-phobia.
