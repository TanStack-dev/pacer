---
source-updated-at: '2025-05-05T07:34:55.000Z'
translation-updated-at: '2025-05-06T23:22:37.193Z'
title: ديل تحديد المعدل (Rate Limiting)
id: rate-limiting
---
# دليل تحديد معدل التنفيذ (Rate Limiting)

تعد تقنيات تحديد معدل التنفيذ (Rate Limiting)، والتحكم في التردد (Throttling)، وإلغاء الاهتزاز (Debouncing) ثلاث طرق مختلفة للتحكم في تكرار تنفيذ الدوال. كل تقنية تمنع عمليات التنفيذ بطريقة مختلفة، مما يجعلها "فاقدة" (lossy) - أي أن بعض استدعاءات الدوال لن تنفذ عند طلب تشغيلها بشكل متكرر جدًا. يعد فهم الوقت المناسب لاستخدام كل تقنية أمرًا بالغ الأهمية لبناء تطبيقات عالية الأداء وموثوقة. سيغطي هذا الدليل مفاهيم تحديد معدل التنفيذ في TanStack Pacer.

> [!ملاحظة]
> TanStack Pacer حاليًا مكتبة للواجهة الأمامية فقط. هذه أدوات لتحديد معدل التنفيذ من جانب العميل.

## مفهوم تحديد معدل التنفيذ (Rate Limiting)

تحديد معدل التنفيذ (Rate Limiting) هو تقنية تحد من المعدل الذي يمكن للدالة أن تنفذ فيه خلال نافذة زمنية محددة. وهي مفيدة بشكل خاص في السيناريوهات التي تريد فيها منع استدعاء الدالة بشكل متكرر جدًا، مثل عند التعامل مع طلبات واجهة برمجة التطبيقات (API) أو استدعاءات الخدمات الخارجية الأخرى. وهي النهج الأكثر *بساطة*، حيث تسمح بتنفيذ الدوال في دفعات حتى يتم استنفاذ الحصة المحددة.

### تصور تحديد معدل التنفيذ

```text
تحديد معدل التنفيذ (حد: 3 استدعاءات لكل نافذة)
الخط الزمني: [1 ثانية لكل علامة]
                                        النافذة 1                  |    النافذة 2            
الاستدعاءات:        ⬇️     ⬇️     ⬇️     ⬇️     ⬇️                             ⬇️     ⬇️
تم التنفيذ:     ✅     ✅     ✅     ❌     ❌                             ✅     ✅
             [=== 3 مسموح بها ===][=== محظور حتى تنتهي النافذة ===][=== نافذة جديدة =======]
```

### متى تستخدم تحديد معدل التنفيذ

يعد تحديد معدل التنفيذ مهمًا بشكل خاص عند التعامل مع عمليات الواجهة الأمامية التي قد تثقل كاهل خدمات الخلفية عن طريق الخطأ أو تسبب مشاكل في الأداء في المتصفح.

من حالات الاستخدام الشائعة:
- منع إرسال طلبات واجهة برمجة التطبيقات (API) بشكل متكرر عن طريق الخطأ من تفاعلات المستخدم السريعة (مثل النقر على الأزرار أو إرسال النماذج)
- السيناريوهات التي يكون فيها السلوك الدفعي مقبولاً ولكنك تريد تحديد الحد الأقصى للمعدل
- الحماية من الحلقات اللانهائية أو العمليات التكرارية عن طريق الخطأ

### متى لا تستخدم تحديد معدل التنفيذ

يعد تحديد معدل التنفيذ النهج الأكثر بساطة للتحكم في تكرار تنفيذ الدوال. وهو الأقل مرونة والأكثر تقييدًا بين التقنيات الثلاث. فكر في استخدام [التحكم في التردد (Throttling)](../guides/throttling) أو [إلغاء الاهتزاز (Debouncing)](../guides/debouncing) بدلاً من ذلك للحصول على تنفيذ أكثر تباعدًا.

> [!تلميح]
> على الأرج لا تريد استخدام "تحديد معدل التنفيذ" لمعظم حالات الاستخدام. فكر في استخدام [التحكم في التردد (Throttling)](../guides/throttling) أو [إلغاء الاهتزاز (Debouncing)](../guides/debouncing) بدلاً من ذلك.

طبيعة تحديد معدل التنفيذ "الفاقدة" تعني أيضًا أن بعض عمليات التنفيذ سيتم رفضها وفقدانها. يمكن أن يكون هذا مشكلة إذا كنت بحاجة إلى التأكد من نجاح جميع عمليات التنفيذ دائمًا. فكر في استخدام [الطابور (Queueing)](../guides/queueing) إذا كنت بحاجة إلى التأكد من وضع جميع عمليات التنفيذ في طابور للتنفيذ، ولكن مع تأخير للتحكم في التردد لإبطاء معدل التنفيذ.

## تحديد معدل التنفيذ في TanStack Pacer

يوفر TanStack Pacer تحديد معدل التنفيذ المتزامن وغير المتزامن من خلال فئات `RateLimiter` و `AsyncRateLimiter` على التوالي (ووظائفهما المقابلة `rateLimit` و `asyncRateLimit`).

### الاستخدام الأساسي مع `rateLimit`

تعد وظيفة `rateLimit` أبسط طريقة لإضافة تحديد معدل التنفيذ إلى أي دالة. إنها مثالية لمعظم حالات الاستخدام حيث تحتاج فقط إلى فرض حد بسيط.

```ts
import { rateLimit } from '@tanstack/pacer'

// تحديد معدل تنفيذ طلبات واجهة برمجة التطبيقات (API) إلى 5 في الدقيقة
const rateLimitedApi = rateLimit(
  (id: string) => fetchUserData(id),
  {
    limit: 5,
    window: 60 * 1000, // 1 دقيقة بالميلي ثانية
    onReject: (rateLimiter) => {
      console.log(`تم تجاوز حد التنفيذ. حاول مرة أخرى بعد ${rateLimiter.getMsUntilNextWindow()} مللي ثانية`)
    }
  }
)

// أول 5 استدعاءات ستنفذ على الفور
rateLimitedApi('user-1') // ✅ يتم التنفيذ
rateLimitedApi('user-2') // ✅ يتم التنفيذ
rateLimitedApi('user-3') // ✅ يتم التنفيذ
rateLimitedApi('user-4') // ✅ يتم التنفيذ
rateLimitedApi('user-5') // ✅ يتم التنفيذ
rateLimitedApi('user-6') // ❌ مرفوض حتى إعادة تعيين النافذة
```

### الاستخدام المتقدم مع فئة `RateLimiter`

بالنسبة للسيناريوهات الأكثر تعقيدًا حيث تحتاج إلى تحكم إضافي في سلوك تحديد معدل التنفيذ، يمكنك استخدام فئة `RateLimiter` مباشرة. وهذا يمنحك الوصول إلى طرق إضافية ومعلومات الحالة.

```ts
import { RateLimiter } from '@tanstack/pacer'

// إنشاء مثيل محدد معدل التنفيذ
const limiter = new RateLimiter(
  (id: string) => fetchUserData(id),
  {
    limit: 5,
    window: 60 * 1000,
    onExecute: (rateLimiter) => {
      console.log('تم تنفيذ الدالة', rateLimiter.getExecutionCount())
    },
    onReject: (rateLimiter) => {
      console.log(`تم تجاوز حد التنفيذ. حاول مرة أخرى بعد ${rateLimiter.getMsUntilNextWindow()} مللي ثانية`)
    }
  }
)

// الحصول على معلومات حول الحالة الحالية
console.log(limiter.getRemainingInWindow()) // عدد الاستدعاءات المتبقية في النافذة الحالية
console.log(limiter.getExecutionCount()) // إجمالي عدد عمليات التنفيذ الناجحة
console.log(limiter.getRejectionCount()) // إجمالي عدد عمليات التنفيذ المرفوضة

// محاولة التنفيذ (تُرجع قيمة منطقية تشير إلى النجاح)
limiter.maybeExecute('user-1')

// تحديث الخيارات ديناميكيًا
limiter.setOptions({ limit: 10 }) // زيادة الحد

// إعادة تعيين جميع العدادات والحالة
limiter.reset()
```

### التمكين/التعطيل

تدعم فئة `RateLimiter` التمكين/التعطيل عبر خيار `enabled`. باستخدام طريقة `setOptions`، يمكنك تمكين/تعطيل محدد معدل التنفيذ في أي وقت:

```ts
const limiter = new RateLimiter(fn, { 
  limit: 5, 
  window: 1000,
  enabled: false // تعطيل افتراضيًا
})
limiter.setOptions({ enabled: true }) // تمكين في أي وقت
```

إذا كنت تستخدم أداة تكيف إطار عمل حيث تكون خيارات محدد معدل التنفيذ تفاعلية، يمكنك تعيين خيار `enabled` إلى قيمة شرطية لتمكين/تعطيل محدد معدل التنفيذ على الفور. ومع ذلك، إذا كنت تستخدم وظيفة `rateLimit` أو فئة `RateLimiter` مباشرة، فيجب عليك استخدام طريقة `setOptions` لتغيير خيار `enabled`، حيث أن الخيارات التي يتم تمريرها يتم تمريرها بالفعل إلى مُنشئ فئة `RateLimiter`.

### خيارات ردود النداء (Callbacks)

يدعم كل من محددات معدل التنفيذ المتزامنة وغير المتزامنة خيارات ردود النداء للتعامل مع جوانب مختلفة من دورة حياة تحديد معدل التنفيذ:

#### ردود نداء محدد معدل التنفيذ المتزامن

يدعم `RateLimiter` المتزامن ردود النداء التالية:

```ts
const limiter = new RateLimiter(fn, {
  limit: 5,
  window: 1000,
  onExecute: (rateLimiter) => {
    // يتم استدعاؤها بعد كل تنفيذ ناجح
    console.log('تم تنفيذ الدالة', rateLimiter.getExecutionCount())
  },
  onReject: (rateLimiter) => {
    // يتم استدعاؤها عند رفض التنفيذ
    console.log(`تم تجاوز حد التنفيذ. حاول مرة أخرى بعد ${rateLimiter.getMsUntilNextWindow()} مللي ثانية`)
  }
})
```

يتم استدعاء رد النداء `onExecute` بعد كل تنفيذ ناجح للدالة محددة المعدل، بينما يتم استدعاء رد النداء `onReject` عند رفض التنفيذ بسبب تحديد معدل التنفيذ. تعد ردود النداء هذه مفيدة لتتبع عمليات التنفيذ، وتحديث حالة واجهة المستخدم، أو توفير ملاحظات للمستخدمين.

#### ردود نداء محدد معدل التنفيذ غير المتزامن

يدعم `AsyncRateLimiter` غير المتزامن ردود نداء إضافية للتعامل مع الأخطاء:

```ts
const asyncLimiter = new AsyncRateLimiter(async (id) => {
  await saveToAPI(id)
}, {
  limit: 5,
  window: 1000,
  onExecute: (rateLimiter) => {
    // يتم استدعاؤها بعد كل تنفيذ ناجح
    console.log('تم تنفيذ الدالة غير المتزامنة', rateLimiter.getExecutionCount())
  },
  onReject: (rateLimiter) => {
    // يتم استدعاؤها عند رفض التنفيذ
    console.log(`تم تجاوز حد التنفيذ. حاول مرة أخرى بعد ${rateLimiter.getMsUntilNextWindow()} مللي ثانية`)
  },
  onError: (error) => {
    // يتم استدعاؤها إذا ألقت الدالة غير المتزامنة خطأ
    console.error('فشلت الدالة غير المتزامنة:', error)
  }
})
```

تعمل ردود النداء `onExecute` و `onReject` بنفس الطريقة كما في محدد معدل التنفيذ المتزامن، بينما يسمح رد النداء `onError` لك بالتعامل مع الأخطاء بسلاسة دون كسر سلسلة تحديد معدل التنفيذ. تعد ردود النداء هذه مفيدة بشكل خاص لتتبع عدد عمليات التنفيذ، وتحديث حالة واجهة المستخدم، والتعامل مع الأخطاء، وتوفير ملاحظات للمستخدمين.

### تحديد معدل التنفيذ غير المتزامن

يوفر محدد معدل التنفيذ غير المتزامن طريقة قوية للتعامل مع العمليات غير المتزامنة مع تحديد معدل التنفيذ، ويقدم عدة مزايا رئيسية مقارنة بالإصدار المتزامن. بينما يعد محدد معدل التنفيذ المتزامن رائعًا لأحداث واجهة المستخدم والملاحظات الفورية، فإن الإصدار غير المتزامن مصمم خصيصًا للتعامل مع استدعاءات واجهة برمجة التطبيقات (API)، وعمليات قاعدة البيانات، والمهام غير المتزامنة الأخرى.

#### الاختلافات الرئيسية عن تحديد معدل التنفيذ المتزامن

1. **معالجة القيمة المرجعة**
على عكس محدد معدل التنفيذ المتزامن الذي يُرجع قيمة منطقية تشير إلى النجاح، يسمح الإصدار غير المتزامن لك بالتقاط واستخدام القيمة المرجعة من الدالة محددة المعدل. هذا مفيد بشكل خاص عندما تحتاج إلى العمل مع نتائج استدعاءات واجهة برمجة التطبيقات (API) أو العمليات غير المتزامنة الأخرى. تُرجع طريقة `maybeExecute` وعدًا (Promise) يحل بقيمة إرجاع الدالة، مما يسمح لك بانتظار النتيجة والتعامل معها بشكل مناسب.

2. **نظام ردود النداء المحسن**
يوفر محدد معدل التنفيذ غير المتزامن نظام ردود نداء أكثر تطورًا مقارنة بردود النداء الخاصة بالإصدار المتزامن. يتضمن هذا النظام:
- `onExecute`: يتم استدعاؤها بعد كل تنفيذ ناجح، وتوفر مثيل محدد معدل التنفيذ
- `onReject`: يتم استدعاؤها عند رفض التنفيذ بسبب تحديد معدل التنفيذ، وتوفر مثيل محدد معدل التنفيذ
- `onError`: يتم استدعاؤها إذا ألقت الدالة غير المتزامنة خطأ، وتوفر كلًا من الخطأ ومثيل محدد معدل التنفيذ

3. **تتبع التنفيذ**
يوفر محدد معدل التنفيذ غير المتزامن تتبعًا شاملاً للتنفيذ من خلال عدة طرق:
- `getExecutionCount()`: عدد عمليات التنفيذ الناجحة
- `getRejectionCount()`: عدد عمليات التنفيذ المرفوضة
- `getRemainingInWindow()`: عدد عمليات التنفيذ المتبقية في النافذة الحالية
- `getMsUntilNextWindow()`: عدد المللي ثانية حتى بدء النافذة التالية

4. **التنفيذ التسلسلي**
يضمن محدد معدل التنفيذ غير المتزامن أن عمليات التنفيذ اللاحقة تنتظر اكتمال الاستدعاء السابق قبل البدء. هذا يمنع التنفيذ خارج الترتيب ويضمن أن كل استدعاء يعالج أحدث البيانات. هذا مهم بشكل خاص عند التعامل مع العمليات التي تعتمد على نتائج الاستدعاءات السابقة أو عندما يكون الحفاظ على اتساق البيانات أمرًا بالغ الأهمية.

على سبيل المثال، إذا كنت تقوم بتحديث ملف تعريف المستخدم ثم تقوم على الفور جلب بياناته المحدثة، فإن محدد معدل التنفيذ غير المتزامن سيتأكد من انتظار عملية الجلب لإكمال التحديث، مما يمنع ظروف السباق (race conditions) حيث قد تحصل على بيانات قديمة.

#### مثال على الاستخدام الأساسي

إليك مثالًا أساسيًا يوضح كيفية استخدام محدد معدل التنفيذ غير المتزامن لعملية واجهة برمجة التطبيقات (API):

```ts
const rateLimitedApi = asyncRateLimit(
  async (id: string) => {
    const response = await fetch(`/api/data/${id}`)
    return response.json()
  },
  {
    limit: 5,
    window: 1000,
    onExecute: (limiter) => {
      console.log('نجاح استدعاء واجهة برمجة التطبيقات (API):', limiter.getExecutionCount())
    },
    onReject: (limiter) => {
      console.log(`تم تجاوز حد التنفيذ. حاول مرة أخرى بعد ${limiter.getMsUntilNextWindow()} مللي ثانية`)
    },
    onError: (error, limiter) => {
      console.error('فشل استدعاء واجهة برمجة التطبيقات (API):', error)
    }
  }
)

// الاستخدام
const result = await rateLimitedApi('123')
```

#### الأنماط المتقدمة

يمكن دمج محدد معدل التنفيذ غير المتزامن مع أنماط مختلفة لحل المشكلات المعقدة:

1. **تكامل إدارة الحالة**
عند استخدام محدد معدل التنفيذ غير المتزامن مع أنظمة إدارة الحالة (مثل useState في React أو createSignal في Solid)، يمكنك إنشاء أنماط قوية للتعامل مع حالات التحميل، وحالات الخطأ، وتحديثات البيانات. توفر ردود النداء الخاصة بمحدد معدل التنفيذ خطافات مثالية لتحديث حالة واجهة المستخدم بناءً على نجاح أو فشل العمليات.

2. **منع ظروف السباق (Race Conditions)**
يمنع نمط تحديد معدل التنفيذ ظروف السباق في العديد من السيناريوهات بشكل طبيعي. عندما تحاول أجزاء متعددة من تطبيقك تحديث نفس المورد في نفس الوقت، يضمن محدد معدل التنفيذ حدوث التحديثات ضمن الحدود المكونة، مع توفير النتائج لجميع المتصلين.

3. **استعادة الخطأ**
تج
