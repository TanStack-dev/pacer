---
source-updated-at: '2025-05-08T02:24:20.000Z'
translation-updated-at: '2025-05-08T06:05:32.754Z'
title: دليل تحديد المعدل (Rate Limiting)
id: rate-limiting
---
# دليل التحديد المسبق لمعدل التنفيذ (Rate Limiting)

تعد تقنيات **التحديد المسبق لمعدل التنفيذ (Rate Limiting)** و**التحكم في معدل التنفيذ (Throttling)** و**إلغاء الاهتزاز (Debouncing)** ثلاث طرق مختلفة للتحكم في معدل تنفيذ الدوال. كل تقنية تمنع عمليات التنفيذ بطريقة مختلفة، مما يجعلها "فاقدة" (lossy) - أي أن بعض استدعاءات الدوال لن تنفذ عند طلب تشغيلها بشكل متكرر جدًا. يعد فهم الوقت المناسب لاستخدام كل نهج أمرًا بالغ الأهمية لبناء تطبيقات عالية الأداء وموثوقة. سيغطي هذا الدليل مفاهيم التحديد المسبق لمعدل التنفيذ في TanStack Pacer.

> [!ملاحظة]
> TanStack Pacer حاليًا مكتبة للواجهة الأمامية فقط. هذه أدوات للتحديد المسبق لمعدل التنفيذ من جانب العميل.

## مفهوم التحديد المسبق لمعدل التنفيذ

التحديد المسبق لمعدل التنفيذ (Rate Limiting) هو تقنية تحد من المعدل الذي يمكن به تنفيذ دالة خلال نافذة زمنية محددة. وهي مفيدة بشكل خاص في السيناريوهات التي تريد فيها منع استدعاء دالة بشكل متكرر جدًا، مثل عند التعامل مع طلبات واجهة برمجة التطبيقات (API) أو استدعاءات الخدمات الخارجية الأخرى. وهي النهج الأكثر *بساطة*، حيث يسمح بتنفيذ الدوال في دفعات حتى يتم استنفاذ الحصة المحددة.

### تصور التحديد المسبق لمعدل التنفيذ

```text
Rate Limiting (limit: 3 calls per window)
Timeline: [1 second per tick]
                                        Window 1                  |    Window 2            
Calls:        ⬇️     ⬇️     ⬇️     ⬇️     ⬇️                             ⬇️     ⬇️
Executed:     ✅     ✅     ✅     ❌     ❌                             ✅     ✅
             [=== 3 allowed ===][=== blocked until window ends ===][=== new window =======]
```

### أنواع النوافذ

يدعم TanStack Pacer نوعين من نوافذ التحديد المسبق لمعدل التنفيذ:

1. **النافذة الثابتة (Fixed Window)** (الافتراضي)
   - نافذة صارمة يتم إعادة تعيينها بعد فترة النافذة
   - جميع عمليات التنفيذ داخل النافذة تحسب ضمن الحد
   - يتم إعادة تعيين النافذة بالكامل بعد الفترة
   - قد يؤدي إلى سلوك متفجر عند حدود النافذة

2. **النافذة المنزلقة (Sliding Window)**
   - نافذة متحركة تسمح بتنفيذ الدوال عند انتهاء صلاحية القديمة
   - توفر معدل تنفيذ أكثر اتساقًا بمرور الوقت
   - أفضل للحفاظ على تدفق ثابت من عمليات التنفيذ
   - يمنع السلوك المتفجر عند حدود النافذة

إليك تصورًا للتحديد المسبق لمعدل التنفيذ بنافذة منزلقة:

```text
Sliding Window Rate Limiting (limit: 3 calls per window)
Timeline: [1 second per tick]
                                        Window 1                  |    Window 2            
Calls:        ⬇️     ⬇️     ⬇️     ⬇️     ⬇️                             ⬇️     ⬇️
Executed:     ✅     ✅     ✅     ❌     ✅                             ✅     ✅
             [=== 3 allowed ===][=== oldest expires, new allowed ===][=== continues sliding =======]
```

الفرق الرئيسي هو أنه مع النافذة المنزلقة، بمجرد انتهاء صلاحية أقدم عملية تنفيذ، يُسمح بتنفيذ جديد. وهذا يخلق تدفقًا أكثر اتساقًا من عمليات التنفيذ مقارنة بنهج النافذة الثابتة.

### متى تستخدم التحديد المسبق لمعدل التنفيذ

يعد التحديد المسبق لمعدل التنفيذ مهمًا بشكل خاص عند التعامل مع عمليات الواجهة الأمامية التي يمكن أن تطغى عن طريق الخطأ على خدمات الخلفية أو تسبب مشاكل في الأداء في المتصفح.

من حالات الاستخدام الشائعة:
- منع البريد المزعج العرضي لواجهة برمجة التطبيقات (API) من تفاعلات المستخدم السريعة (مثل النقر على الأزرار أو إرسال النماذج)
- السيناريوهات التي يكون فيها السلوك المتفجر مقبولًا ولكنك تريد تحديد الحد الأقصى للمعدل
- الحماية من الحلقات اللانهائية العرضية أو العمليات المتكررة

### متى لا تستخدم التحديد المسبق لمعدل التنفيذ

يعد التحديد المسبق لمعدل التنفيذ النهج الأكثر بساطة للتحكم في معدل تنفيذ الدوال. وهو الأقل مرونة والأكثر تقييدًا من بين التقنيات الثلاث. فكر في استخدام [التحكم في معدل التنفيذ (Throttling)](../guides/throttling) أو [إلغاء الاهتزاز (Debouncing)](../guides/debouncing) بدلاً من ذلك للحصول على عمليات تنفيذ أكثر تباعدًا.

> [!تلميح]
> على الأرجح لا تريد استخدام "التحديد المسبق لمعدل التنفيذ" لمعظم حالات الاستخدام. فكر في استخدام [التحكم في معدل التنفيذ (Throttling)](../guides/throttling) أو [إلغاء الاهتزاز (Debouncing)](../guides/debouncing) بدلاً من ذلك.

طبيعة التحديد المسبق لمعدل التنفيذ "الفاقدة" تعني أيضًا أن بعض عمليات التنفيذ سيتم رفضها وفقدانها. يمكن أن يكون هذا مشكلة إذا كنت بحاجة إلى التأكد من أن جميع عمليات التنفيذ ناجحة دائمًا. فكر في استخدام [الانتظار في قائمة (Queueing)](../guides/queueing) إذا كنت بحاجة إلى التأكد من أن جميع عمليات التنفيذ في قائمة انتظار للتنفيذ، ولكن مع تأخير مقيّد لإبطاء معدل التنفيذ.

## التحديد المسبق لمعدل التنفيذ في TanStack Pacer

يوفر TanStack Pacer تحديدًا مسبقًا لمعدل التنفيذ المتزامن وغير المتزامن من خلال فئتي `RateLimiter` و `AsyncRateLimiter` على التوالي (ووظائفهما المقابلة `rateLimit` و `asyncRateLimit`).

### الاستخدام الأساسي مع `rateLimit`

تعد وظيفة `rateLimit` أبسط طريقة لإضافة تحديد مسبق لمعدل التنفيذ إلى أي دالة. إنها مثالية لمعظم حالات الاستخدام حيث تحتاج فقط إلى فرض حد بسيط.

```ts
import { rateLimit } from '@tanstack/pacer'

// تحديد مسبق لمعدل تنفيذ استدعاءات واجهة برمجة التطبيقات (API) إلى 5 في الدقيقة
const rateLimitedApi = rateLimit(
  (id: string) => fetchUserData(id),
  {
    limit: 5,
    window: 60 * 1000, // 1 دقيقة بالميلي ثانية
    windowType: 'fixed', // افتراضي
    onReject: (rateLimiter) => {
      console.log(`تم تجاوز الحد المسبق لمعدل التنفيذ. حاول مرة أخرى بعد ${rateLimiter.getMsUntilNextWindow()}ms`)
    }
  }
)

// أول 5 استدعاءات ستنفذ على الفور
rateLimitedApi('user-1') // ✅ يتم التنفيذ
rateLimitedApi('user-2') // ✅ يتم التنفيذ
rateLimitedApi('user-3') // ✅ يتم التنفيذ
rateLimitedApi('user-4') // ✅ يتم التنفيذ
rateLimitedApi('user-5') // ✅ يتم التنفيذ
rateLimitedApi('user-6') // ❌ يتم الرفض حتى إعادة تعيين النافذة
```

### استخدام متقدم مع فئة `RateLimiter`

بالنسبة للسيناريوهات الأكثر تعقيدًا حيث تحتاج إلى تحكم إضافي في سلوك التحديد المسبق لمعدل التنفيذ، يمكنك استخدام فئة `RateLimiter` مباشرة. وهذا يمنحك الوصول إلى طرق ومعلومات حالة إضافية.

```ts
import { RateLimiter } from '@tanstack/pacer'

// إنشاء مثيل محدد لمعدل التنفيذ
const limiter = new RateLimiter(
  (id: string) => fetchUserData(id),
  {
    limit: 5,
    window: 60 * 1000,
    onExecute: (rateLimiter) => {
      console.log('تم تنفيذ الدالة', rateLimiter.getExecutionCount())
    },
    onReject: (rateLimiter) => {
      console.log(`تم تجاوز الحد المسبق لمعدل التنفيذ. حاول مرة أخرى بعد ${rateLimiter.getMsUntilNextWindow()}ms`)
    }
  }
)

// الحصول على معلومات حول الحالة الحالية
console.log(limiter.getRemainingInWindow()) // عدد الاستدعاءات المتبقية في النافذة الحالية
console.log(limiter.getExecutionCount()) // إجمالي عدد عمليات التنفيذ الناجحة
console.log(limiter.getRejectionCount()) // إجمالي عدد عمليات التنفيذ المرفوضة

// محاولة التنفيذ (تُرجع قيمة منطقية تشير إلى النجاح)
limiter.maybeExecute('user-1')

// تحديث الخيارات ديناميكيًا
limiter.setOptions({ limit: 10 }) // زيادة الحد

// إعادة تعيين جميع العدادات والحالة
limiter.reset()
```

### التمكين/التعطيل

تدعم فئة `RateLimiter` التمكين/التعطيل عبر خيار `enabled`. باستخدام طريقة `setOptions`، يمكنك تمكين/تعطيل محدد معدل التنفيذ في أي وقت:

> [!ملاحظة]
> خيار `enabled` يمكّن/يعطل تنفيذ الدالة الفعلي. تعطيل محدد معدل التنفيذ لا يوقف التحديد المسبق لمعدل التنفيذ، بل يمنع فقط تنفيذ الدالة تمامًا.

```ts
const limiter = new RateLimiter(fn, { 
  limit: 5, 
  window: 1000,
  enabled: false // تعطيل افتراضيًا
})
limiter.setOptions({ enabled: true }) // تمكين في أي وقت
```

إذا كنت تستخدم أداة تكيف إطار عمل حيث تكون خيارات محدد معدل التنفيذ تفاعلية، يمكنك تعيين خيار `enabled` إلى قيمة شرطية لتمكين/تعطيل محدد معدل التنفيذ على الفور. ومع ذلك، إذا كنت تستخدم وظيفة `rateLimit` أو فئة `RateLimiter` مباشرة، يجب عليك استخدام طريقة `setOptions` لتغيير خيار `enabled`، حيث أن الخيارات التي يتم تمريرها يتم تمريرها بالفعل إلى مُنشئ فئة `RateLimiter`.

### خيارات ردود النداء

يدعم كل من محددات معدل التنفيذ المتزامنة وغير المتزامنة خيارات ردود النداء للتعامل مع جوانب مختلفة من دورة حياة التحديد المسبق لمعدل التنفيذ:

#### ردود نداء محدد معدل التنفيذ المتزامن

يدعم `RateLimiter` المتزامن ردود النداء التالية:

```ts
const limiter = new RateLimiter(fn, {
  limit: 5,
  window: 1000,
  onExecute: (rateLimiter) => {
    // يتم استدعاؤها بعد كل تنفيذ ناجح
    console.log('تم تنفيذ الدالة', rateLimiter.getExecutionCount())
  },
  onReject: (rateLimiter) => {
    // يتم استدعاؤها عند رفض تنفيذ
    console.log(`تم تجاوز الحد المسبق لمعدل التنفيذ. حاول مرة أخرى بعد ${rateLimiter.getMsUntilNextWindow()}ms`)
  }
})
```

يتم استدعاء رد النداء `onExecute` بعد كل تنفيذ ناجح للدالة المحددة مسبقًا لمعدل التنفيذ، بينما يتم استدعاء رد النداء `onReject` عند رفض تنفيذ بسبب التحديد المسبق لمعدل التنفيذ. تعد ردود النداء هذه مفيدة لتتبع عمليات التنفيذ، وتحديث حالة واجهة المستخدم، أو توفير ملاحظات للمستخدمين.

#### ردود نداء محدد معدل التنفيذ غير المتزامن

يدعم `AsyncRateLimiter` ردود نداء إضافية للتعامل مع الأخطاء:

```ts
const asyncLimiter = new AsyncRateLimiter(async (id) => {
  await saveToAPI(id)
}, {
  limit: 5,
  window: 1000,
  onExecute: (rateLimiter) => {
    // يتم استدعاؤها بعد كل تنفيذ ناجح
    console.log('تم تنفيذ الدالة غير المتزامنة', rateLimiter.getExecutionCount())
  },
  onReject: (rateLimiter) => {
    // يتم استدعاؤها عند رفض تنفيذ
    console.log(`تم تجاوز الحد المسبق لمعدل التنفيذ. حاول مرة أخرى بعد ${rateLimiter.getMsUntilNextWindow()}ms`)
  },
  onError: (error) => {
    // يتم استدعاؤها إذا ألقت الدالة غير المتزامنة خطأ
    console.error('فشلت الدالة غير المتزامنة:', error)
  }
})
```

تعمل ردود النداء `onExecute` و `onReject` بنفس الطريقة كما في محدد معدل التنفيذ المتزامن، بينما يسمح رد النداء `onError` بالتعامل مع الأخطاء بأمان دون كسر سلسلة التحديد المسبق لمعدل التنفيذ. تعد ردود النداء هذه مفيدة بشكل خاص لتتبع عدد عمليات التنفيذ، وتحديث حالة واجهة المستخدم، والتعامل مع الأخطاء، وتوفير ملاحظات للمستخدمين.

### التحديد المسبق لمعدل التنفيذ غير المتزامن

يوفر محدد معدل التنفيذ غير المتزامن طريقة قوية للتعامل مع العمليات غير المتزامنة مع التحديد المسبق لمعدل التنفيذ، ويقدم عدة مزايا رئيسية مقارنة بالإصدار المتزامن. بينما يعد محدد معدل التنفيذ المتزامن رائعًا لأحداث واجهة المستخدم والملاحظات الفورية، فإن الإصدار غير المتزامن مصمم خصيصًا للتعامل مع استدعاءات واجهة برمجة التطبيقات (API)، وعمليات قاعدة البيانات، والمهام غير المتزامنة الأخرى.

#### الاختلافات الرئيسية عن التحديد المسبق لمعدل التنفيذ المتزامن

1. **معالجة قيمة الإرجاع**
على عكس محدد معدل التنفيذ المتزامن الذي يُرجع قيمة منطقية تشير إلى النجاح، يسمح الإصدار غير المتزامن لك بالتقاط واستخدام قيمة الإرجاع من الدالة المحددة مسبقًا لمعدل التنفيذ. وهذا مفيد بشكل خاص عندما تحتاج إلى العمل مع نتائج استدعاءات واجهة برمجة التطبيقات (API) أو العمليات غير المتزامنة الأخرى. تُرجع طريقة `maybeExecute` وعدًا (Promise) يتم حله بقيمة إرجاع الدالة، مما يسمح لك بانتظار النتيجة والتعامل معها بشكل مناسب.

2. **ردود نداء مختلفة**
يدعم `AsyncRateLimiter` ردود النداء التالية بدلاً من `onExecute` فقط في الإصدار المتزامن:
- `onSuccess`: يتم استدعاؤها بعد كل تنفيذ ناجح، وتوفر مثيل محدد معدل التنفيذ
- `onSettled`: يتم استدعاؤها بعد كل تنفيذ، وتوفر مثيل محدد معدل التنفيذ
- `onError`: يتم استدعاؤها إذا ألقت الدالة غير المتزامنة خطأ، وتوفر كلًا من الخطأ ومثيل محدد معدل التنفيذ

يدعم كل من محددات معدل التنفيذ غير المتزامنة والمتزامنة رد النداء `onReject` للتعامل مع عمليات التنفيذ المحظورة.

3. **التنفيذ المتسلسل**
نظرًا لأن طريقة `maybeExecute` لمحدد معدل التنفيذ تُرجع وعدًا (Promise)، يمكنك اختيار انتظار كل تنفيذ قبل بدء التالي. وهذا يمنحك التحكم في ترتيب التنفيذ ويضمن معالجة كل استدعاء لأحدث البيانات. وهذا مفيد بشكل خاص عند التعامل مع العمليات التي تعتمد على نتائج الاستدعاءات السابقة أو عندما يكون الحفاظ على اتساق البيانات أمرًا بالغ الأهمية.

على سبيل المثال، إذا كنت تقوم بتحديث ملف تعريف المستخدم ثم تقوم على الفور جلب بياناته المحدثة، يمكنك انتظار عملية التحديث قبل بدء الجلب:

#### مثال على الاستخدام الأساس
