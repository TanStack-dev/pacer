---
source-updated-at: '2025-05-05T07:34:55.000Z'
translation-updated-at: '2025-05-06T23:22:36.023Z'
title: دليل التخلص من الارتداد (Debouncing)
id: debouncing
---
# دليل التخميد (Debouncing)

تعتبر تقنيات تحديد المعدل (Rate Limiting)، التخميد (Throttling)، والتخميد (Debouncing) ثلاث طرق مختلفة للتحكم في تكرار تنفيذ الدوال. كل تقنية تمنع عمليات التنفيذ بشكل مختلف، مما يجعلها "فاقدة" (lossy) - أي أن بعض استدعاءات الدوال لن تنفذ عند طلب تشغيلها بشكل متكرر جدًا. فهم الوقت المناسب لاستخدام كل نهج أمر بالغ الأهمية لبناء تطبيقات عالية الأداء وموثوقة. سيغطي هذا الدليل مفاهيم التخميد (Debouncing) في TanStack Pacer.

## مفهوم التخميد (Debouncing)

التخميد (Debouncing) هو تقنية تؤخر تنفيذ الدالة حتى مرور فترة محددة من عدم النشاط. على عكس تحديد المعدل (Rate Limiting) الذي يسمح باندفاعات من عمليات التنفيذ حتى حد معين، أو التخميد (Throttling) الذي يضمن تنفيذًا متباعدًا بشكل متساوٍ، فإن التخميد (Debouncing) يدمج عدة استدعاءات سريعة للدالة في تنفيذ واحد يحدث فقط بعد توقف الاستدعاءات. هذا يجعل التخميد (Debouncing) مثاليًا للتعامل مع اندفاعات الأحداث حيث تهتم فقط بالحالة النهائية بعد استقرار النشاط.

### تصور التخميد (Debouncing)

```text
Debouncing (wait: 3 ticks)
Timeline: [1 second per tick]
Calls:        �  ⬇️  ⬇️  ⬇️  ⬇️     ⬇️  ⬇️  ⬇️  ⬇️               ⬇️  ⬇️
Executed:     ❌  ❌  ❌  ❌  ❌     ❌  ❌  ❌  ⏳   ->   ✅     ❌  ⏳   ->    ✅
             [=================================================================]
                                                        ^ Executes here after
                                                         3 ticks of no calls

             [Burst of calls]     [More calls]   [Wait]      [New burst]
             No execution         Resets timer    [Delayed Execute]  [Wait] [Delayed Execute]
```

### متى تستخدم التخميد (Debouncing)

التخميد (Debouncing) فعال بشكل خاص عندما تريد الانتظار حتى "توقف" النشاط قبل اتخاذ إجراء. هذا يجعله مثاليًا للتعامل مع مدخلات المستخدم أو الأحداث الأخرى التي يتم تشغيلها بسرعة حيث تهتم فقط بالحالة النهائية.

من حالات الاستخدام الشائعة:
- حقول إدخال البحث حيث تريد الانتظار حتى ينتهي المستخدم من الكتابة
- التحقق من صحة النموذج الذي لا يجب أن يعمل مع كل ضغطة مفتاح
- حسابات تغيير حجم النافذة التي تكون مكلفة في الحساب
- الحفظ التلقائي للمسودات أثناء تحرير المحتوى
- استدعاءات API التي يجب أن تحدث فقط بعد استقرار نشاط المستخدم
- أي سيناريو حيث تهتم فقط بالقيمة النهائية بعد التغييرات السريعة

### متى لا تستخدم التخميد (Debouncing)

قد لا يكون التخميد (Debouncing) هو الخيار الأفضل عندما:
- تحتاج إلى تنفيذ مضمون خلال فترة زمنية محددة (استخدم [التخميد (Throttling)](../guides/throttling) بدلاً من ذلك)
- لا يمكنك تحمل فقدان أي عمليات تنفيذ (استخدم [الانتظار في قائمة (Queueing)](../guides/queueing) بدلاً من ذلك)

## التخميد (Debouncing) في TanStack Pacer

يوفر TanStack Pacer كلاً من التخميد المتزامن وغير المتزامن من خلال فئتي `Debouncer` و `AsyncDebouncer` على التوالي (ووظائفهما المقابلة `debounce` و `asyncDebounce`).

### الاستخدام الأساسي مع `debounce`

تعتبر دالة `debounce` أبسط طريقة لإضافة التخميد (Debouncing) إلى أي دالة:

```ts
import { debounce } from '@tanstack/pacer'

// تخميد إدخال البحث للانتظار حتى يتوقف المستخدم عن الكتابة
const debouncedSearch = debounce(
  (searchTerm: string) => performSearch(searchTerm),
  {
    wait: 500, // الانتظار 500 مللي ثانية بعد آخر ضغطة مفتاح
  }
)

searchInput.addEventListener('input', (e) => {
  debouncedSearch(e.target.value)
})
```

### الاستخدام المتقدم مع فئة `Debouncer`

لمزيد من التحكم في سلوك التخميد (Debouncing)، يمكنك استخدام فئة `Debouncer` مباشرة:

```ts
import { Debouncer } from '@tanstack/pacer'

const searchDebouncer = new Debouncer(
  (searchTerm: string) => performSearch(searchTerm),
  { wait: 500 }
)

// الحصول على معلومات حول الحالة الحالية
console.log(searchDebouncer.getExecutionCount()) // عدد عمليات التنفيذ الناجحة
console.log(searchDebouncer.getIsPending()) // ما إذا كان هناك استدعاء معلق

// تحديث الخيارات ديناميكيًا
searchDebouncer.setOptions({ wait: 1000 }) // زيادة وقت الانتظار

// إلغاء التنفيذ المعلق
searchDebouncer.cancel()
```

### التنفيذ الأولي والنهائي

يدعم المخمد المتزامن كلاً من عمليات التنفيذ على الحافة الأولية والنهائية:

```ts
const debouncedFn = debounce(fn, {
  wait: 500,
  leading: true,   // التنفيذ عند أول استدعاء
  trailing: true,  // التنفيذ بعد فترة الانتظار
})
```

- `leading: true` - يتم تنفيذ الدالة فورًا عند أول استدعاء
- `leading: false` (الافتراضي) - يبدأ أول استدعاء مؤقت الانتظار
- `trailing: true` (الافتراضي) - يتم تنفيذ الدالة بعد فترة الانتظار
- `trailing: false` - لا يوجد تنفيذ بعد فترة الانتظار

أنماط شائعة:
- `{ leading: false, trailing: true }` - الافتراضي، التنفيذ بعد الانتظار
- `{ leading: true, trailing: false }` - التنفيذ فورًا، تجاهل الاستدعاءات اللاحقة
- `{ leading: true, trailing: true }` - التنفيذ عند أول استدعاء وبعد الانتظار

### وقت الانتظار الأقصى

لا يحتوي مخمد TanStack Pacer عن قصد على خيار `maxWait` مثل مكتبات التخميد (Debouncing) الأخرى. إذا كنت بحاجة إلى السماح بتنفيذ عمليات على فترة زمنية أكثر تباعدًا، ففكر في استخدام تقنية [التخميد (Throttling)](../guides/throttling) بدلاً من ذلك.

### التمكين/التعطيل

تدعم فئة `Debouncer` التمكين/التعطيل عبر خيار `enabled`. باستخدام طريقة `setOptions`، يمكنك تمكين/تعطيل المخمد في أي وقت:

```ts
const debouncer = new Debouncer(fn, { wait: 500, enabled: false }) // التعطيل افتراضيًا
debouncer.setOptions({ enabled: true }) // التمكين في أي وقت
```

إذا كنت تستخدم محول إطار عمل حيث تكون خيارات المخمد تفاعلية، يمكنك تعيين خيار `enabled` إلى قيمة شرطية لتمكين/تعطيل المخمد على الفور:

```ts
// مثال React
const debouncer = useDebouncer(
  setSearch, 
  { wait: 500, enabled: searchInput.value.length > 3 } // تمكين/تعطيل بناءً على طول الإدخال إذا كنت تستخدم محول إطار عمل يدعم الخيارات التفاعلية
)
```

ومع ذلك، إذا كنت تستخدم دالة `debounce` أو فئة `Debouncer` مباشرة، فيجب عليك استخدام طريقة `setOptions` لتغيير خيار `enabled`، حيث أن الخيارات التي يتم تمريرها يتم تمريرها بالفعل إلى منشئ فئة `Debouncer`.

```ts
// مثال Solid
const debouncer = new Debouncer(fn, { wait: 500, enabled: false }) // التعطيل افتراضيًا
createEffect(() => {
  debouncer.setOptions({ enabled: search().length > 3 }) // تمكين/تعطيل بناءً على طول الإدخال
})
```

### خيارات رد الاتصال

يدعم كل من المخمد المتزامن وغير المتزامن خيارات رد الاتصال للتعامل مع جوانب مختلفة من دورة حياة التخميد (Debouncing):

#### ردود الاتصال للمخمد المتزامن

يدعم المخمد المتزامن `Debouncer` رد الاتصال التالي:

```ts
const debouncer = new Debouncer(fn, {
  wait: 500,
  onExecute: (debouncer) => {
    // يتم استدعاؤه بعد كل تنفيذ ناجح
    console.log('تم تنفيذ الدالة', debouncer.getExecutionCount())
  }
})
```

يتم استدعاء رد الاتصال `onExecute` بعد كل تنفيذ ناجح للدالة المخمدة، مما يجعله مفيدًا لتتبع عمليات التنفيذ، تحديث حالة واجهة المستخدم، أو تنفيذ عمليات التنظيف.

#### ردود الاتصال للمخمد غير المتزامن

يحتوي المخمد غير المتزامن `AsyncDebouncer` على مجموعة مختلفة من ردود الاتصال مقارنة بالإصدار المتزامن.

```ts
const asyncDebouncer = new AsyncDebouncer(async (value) => {
  await saveToAPI(value)
}, {
  wait: 500,
  onSuccess: (result, debouncer) => {
    // يتم استدعاؤه بعد كل تنفيذ ناجح
    console.log('تم تنفيذ الدالة غير المتزامنة', debouncer.getSuccessCount())
  },
  onSettled: (debouncer) => {
    // يتم استدعاؤه بعد كل محاولة تنفيذ
    console.log('استقرت الدالة غير المتزامنة', debouncer.getSettledCount())
  },
  onError: (error) => {
    // يتم استدعاؤه إذا ألقت الدالة غير المتزامنة خطأ
    console.error('فشلت الدالة غير المتزامنة:', error)
  }
})
```

يتم استدعاء رد الاتصال `onSuccess` بعد كل تنفيذ ناجح للدالة المخمدة، بينما يتم استدعاء رد الاتصال `onError` إذا ألقت الدالة غير المتزامنة خطأ. يتم استدعاء رد الاتصال `onSettled` بعد كل محاولة تنفيذ، بغض النظر عن النجاح أو الفشل. تعتبر ردود الاتصال هذه مفيدة بشكل خاص لتتبع عدد عمليات التنفيذ، تحديث حالة واجهة المستخدم، معالجة الأخطاء، تنفيذ عمليات التنظيف، وتسجيل مقاييس التنفيذ.

### التخميد غير المتزامن (Async Debouncing)

يوفر المخمد غير المتزامن طريقة قوية للتعامل مع العمليات غير المتزامنة مع التخميد (Debouncing)، ويقدم عدة مزايا رئيسية مقارنة بالإصدار المتزامن. بينما يكون المخمد المتزامن رائعًا لأحداث واجهة المستخدم والملاحظات الفورية، فإن الإصدار غير المتزامن مصمم خصيصًا للتعامل مع استدعاءات API، عمليات قاعدة البيانات، والمهام غير المتزامنة الأخرى.

#### الاختلافات الرئيسية عن التخميد المتزامن

1. **معالجة القيمة المرجعة**
على عكس المخمد المتزامن الذي يُرجع void، يسمح الإصدار غير المتزامن لك بالتقاط واستخدام القيمة المرجعة من دالتك المخمدة. هذا مفيد بشكل خاص عندما تحتاج إلى العمل مع نتائج استدعاءات API أو العمليات غير المتزامنة الأخرى. تُرجع طريقة `maybeExecute` وعدًا (Promise) يحل بقيمة إرجاع الدالة، مما يسمح لك بالانتظار للنتائج ومعالجتها بشكل مناسب.

2. **نظام رد الاتصال المحسن**
يوفر المخمد غير المتزامن نظام رد اتصال أكثر تطورًا مقارنة برد الاتصال الفردي `onExecute` في الإصدار المتزامن. يتضمن هذا النظام:
- `onSuccess`: يتم استدعاؤه عند اكتمال الدالة غير المتزامنة بنجاح، ويوفر كلًا من النتيجة ومثيل المخمد
- `onError`: يتم استدعاؤه عندما تلقى الدالة غير المتزامنة خطأ، ويوفر كلًا من الخطأ ومثيل المخمد
- `onSettled`: يتم استدعاؤه بعد كل محاولة تنفيذ، بغض النظر عن النجاح أو الفشل

3. **تتبع التنفيذ**
يوفر المخمد غير المتزامن تتبعًا شاملًا للتنفيذ من خلال عدة طرق:
- `getSuccessCount()`: عدد عمليات التنفيذ الناجحة
- `getErrorCount()`: عدد عمليات التنفيذ الفاشلة
- `getSettledCount()`: إجمالي عدد عمليات التنفيذ المستقرة (النجاح + الفشل)

4. **التنفيذ المتسلسل**
يضمن المخمد غير المتزامن أن عمليات التنفيذ اللاحقة تنتظر اكتمال الاستدعاء السابق قبل البدء. هذا يمنع التنفيذ خارج الترتيب ويضمن أن كل استدعاء يعالج أحدث البيانات. هذا مهم بشكل خاص عند التعامل مع العمليات التي تعتمد على نتائج الاستدعاءات السابقة أو عندما يكون الحفاظ على تناسق البيانات أمرًا بالغ الأهمية.

على سبيل المثال، إذا كنت تقوم بتحديث ملف تعريف المستخدم ثم تقوم على الفور جلب بياناته المحدثة، فإن المخمد غير المتزامن سيتأكد من أن عملية الجلب تنتظر اكتمال التحديث، مما يمنع ظروف السباق (race conditions) حيث قد تحصل على بيانات قديمة.

#### مثال على الاستخدام الأساسي

إليك مثالًا أساسيًا يوضح كيفية استخدام المخمد غير المتزامن لعملية بحث:

```ts
const debouncedSearch = asyncDebounce(
  async (searchTerm: string) => {
    const results = await fetchSearchResults(searchTerm)
    return results
  },
  {
    wait: 500,
    onSuccess: (results, debouncer) => {
      console.log('نجاح البحث:', results)
    },
    onError: (error, debouncer) => {
      console.error('فشل البحث:', error)
    }
  }
)

// الاستخدام
const results = await debouncedSearch('query')
```

#### أنماط متقدمة

يمكن دمج المخمد غير المتزامن مع أنماط مختلفة لحل المشكلات المعقدة:

1. **تكامل إدارة الحالة**
عند استخدام المخمد غير المتزامن مع أنظمة إدارة الحالة (مثل useState في React أو createSignal في Solid)، يمكنك إنشاء أنماط قوية للتعامل مع حالات التحميل، حالات الخطأ، وتحديثات البيانات. توفر ردود اتصال المخمد خطاطيف مثالية لتحديث حالة واجهة المستخدم بناءً على نجاح أو فشل العمليات.

2. **منع ظروف السباق (Race Conditions)**
يمنع نمط التحور ذو الرحلة الواحدة (single-flight mutation) ظروف السباق في العديد من السيناريوهات. عندما تحاول أجزاء متعددة من تطبيقك تحديث نفس المورد في نفس الوقت، يضمن المخمد أن أحدث تحديث فقط هو الذي يحدث فعليًا، مع توفير النتائج لجميع المتصلين.

3. **استعادة الخطأ**
تجعل قدرات معالجة الأخطاء للمخمد غير المتزامن منه مثاليًا لتنفيذ منطق إعادة المحاولة وأنماط استعادة الخطأ. يمكنك استخدام رد الاتصال `onError` لتنفيذ استراتيجيات معالجة أخطاء مخصصة، مثل التراجع الأسي (exponential backoff) أو آليات الاحتياطي.

### محولات الأطر (Framework Adapters)

يوفر كل محول إطار خطاطيف تبني على وظيفة التخميد الأساسية للتكامل مع نظام إدارة الحالة الخاص بالإطار. تتوفر خطاطيف مثل `createDebouncer`، `useDebouncedCallback`، `useDebouncedState`، أو `useDebouncedValue` لكل إطار.

إليك بعض الأمثلة:

#### React

```tsx
import { useDebouncer, useDebouncedCallback, useDebouncedValue } from '@tanstack/react-pacer'

// خطاف منخفض المستوى للتحكم الكامل
const debouncer = useDebouncer(
  (value: string) => saveToDatabase(value),
  { wait: 500 }
)

// خطاف رد اتصال بسيط لحالات الاستخدام الأساسية
const handleSearch = useDebouncedCallback(
  (query: string) => fetchSearchResults(query),
  { wait: 500 }
)

// خطاف قائم على الحالة لإدارة الحالة التفاعلية
const [instantState, setInstantState] = useState('')
const [debouncedValue] = useDebounced
