---
source-updated-at: '2025-04-24T12:27:47.000Z'
translation-updated-at: '2025-05-02T04:15:14.183Z'
title: キューイングガイド
id: queueing
---
# キューイングガイド

[レートリミット](../guides/rate-limiting)、[スロットリング](../guides/throttling)、[デバウンス](../guides/debouncing)が頻繁に発生する実行をドロップするのとは異なり、キューイングはすべての操作が処理されることを保証します。キューイングはリクエストを失うことなく操作の流れを管理・制御する方法を提供します。これにより、データ損失が許容できないシナリオに最適です。このガイドではTanStack Pacerのキューイングコンセプトについて説明します。

## キューイングのコンセプト

キューイングは、処理が追いつかないほど速く操作が発生した場合でも、すべての操作が最終的に処理されることを保証します。他の実行制御技術が過剰な操作をドロップするのに対し、キューイングは操作を順序付きリストにバッファリングし、特定のルールに従って処理します。これにより、キューイングはTanStack Pacerで唯一の「ロスレス」な実行制御技術となります。

### キューイングの可視化

```text
キューイング (2ティックごとに1アイテム処理)
タイムライン: [1秒/ティック]
呼び出し:      ⬇️  ⬇️  ⬇️     ⬇️  ⬇️     ⬇️  ⬇️  ⬇️
キュー:       [ABC]   [BC]    [BCDE]    [DE]    [E]    []
実行済み:     ✅     ✅       ✅        ✅      ✅     ✅
             [=================================================================]
             ^ レートリミット/スロットリング/デバウンスとは異なり、
               すべての呼び出しが順番に最終的に処理されます

             [アイテムがキューに蓄積]   [1つずつ安定処理]   [キュー空]
              ビジー時                  順次処理            空状態
```

### キューイングを使用するタイミング

キューイングは、多少の遅延が発生してもすべての操作を処理する必要がある場合に特に重要です。これは、即時実行よりもデータの一貫性と完全性が重要なシナリオに最適です。

一般的な使用例:
- すべてのアクションを記録する必要があるUIでのユーザーインタラクション処理
- データ一貫性を維持する必要があるデータベース操作の処理
- すべて正常に完了する必要があるAPIリクエストの管理
- ドロップできないバックグラウンドタスクの調整
- すべてのフレームが重要なアニメーションシーケンス
- すべてのエントリを保存する必要があるフォーム送信

### キューイングを使用しないタイミング

以下の場合、キューイングは最適な選択ではないかもしれません:
- すべての操作を処理するよりも即時のフィードバックが重要な場合
- 最新の値のみが重要な場合（代わりに[デバウンス](../guides/debouncing)を使用）

> [!TIP]
> 現在レートリミット、スロットリング、またはデバウンスを使用していて、ドロップされた操作が問題を引き起こしている場合、キューイングがおそらく必要な解決策です。

## TanStack Pacerでのキューイング

TanStack Pacerは、シンプルな`queue`関数とより強力な`Queuer`クラスを通じてキューイングを提供します。他の実行制御技術が通常関数ベースのAPIを好むのに対し、キューイングはクラスベースのAPIが提供する追加制御から恩恵を受けることが多いです。

### `queue`による基本的な使用法

`queue`関数は、アイテムが追加されるとすぐに処理する常時実行キューを作成する簡単な方法を提供します:

```ts
import { queue } from '@tanstack/pacer'

// 1秒ごとにアイテムを処理するキューを作成
const processItems = queue<number>({
  wait: 1000,
  onItemsChange: (queuer) => {
    console.log('現在のキュー:', queuer.getAllItems())
  }
})

// 処理するアイテムを追加
processItems(1) // 即時処理
processItems(2) // 1秒後に処理
processItems(3) // 2秒後に処理
```

`queue`関数は簡単に使用できますが、`addItem`メソッドを通じて基本的な常時実行キューしか提供しません。ほとんどの使用例では、`Queuer`クラスが提供する追加の制御と機能が必要になるでしょう。

### `Queuer`クラスによる高度な使用法

`Queuer`クラスはキュー動作と処理を完全に制御できます:

```ts
import { Queuer } from '@tanstack/pacer'

// 1秒ごとにアイテムを処理するキューを作成
const queue = new Queuer<number>({
  wait: 1000, // アイテム間で1秒待機
  onItemsChange: (queuer) => {
    console.log('現在のキュー:', queuer.getAllItems())
  }
})

// 処理を開始
queue.start()

// 処理するアイテムを追加
queue.addItem(1)
queue.addItem(2)
queue.addItem(3)

// アイテムは1つずつ、各間に1秒の遅延で処理されます
// 出力:
// 処理中: 1 (即時)
// 処理中: 2 (1秒後)
// 処理中: 3 (2秒後)
```

### キューの種類と順序付け

TanStack PacerのQueuerの特徴は、位置ベースのAPIを通じてさまざまな使用例に適応できることです。同じQueuerが、一貫したインターフェースを通じて、従来のキュー、スタック、または両端キューとして動作できます。

#### FIFOキュー (先入れ先出し)

アイテムが追加された順に処理されるデフォルトの動作です。最も一般的なキュータイプで、最初に追加されたアイテムが最初に処理されるという原則に従います。

```text
FIFOキューの可視化:

エントリー →  [A][B][C][D] → エグジット
             ⬇️         ⬆️
          新しいアイテム   アイテムは
          ここに追加     ここで処理

タイムライン: [1秒/ティック]
呼び出し:      ⬇️  ⬇️  ⬇️     ⬇️
キュー:       [ABC]   [BC]    [C]    []
処理済み:    A       B       C
```

FIFOキューは以下に最適:
- 順序が重要なタスク処理
- メッセージを順番に処理する必要があるメッセージキュー
- 送信順にドキュメントを印刷する必要がある印刷キュー
- イベントを時系列で処理する必要があるイベント処理システム

```ts
const queue = new Queuer<number>({
  addItemsTo: 'back', // デフォルト
  getItemsFrom: 'front', // デフォルト
})
queue.addItem(1) // [1]
queue.addItem(2) // [1, 2]
// 処理順: 1, 次に2
```

#### LIFOスタック (後入れ先出し)

アイテムの追加と取得の両方に'back'を指定すると、キューはスタックのように動作します。スタックでは、最も最近追加されたアイテムが最初に処理されます。

```text
LIFOスタックの可視化:

     ⬆️ 処理
    [D] ← 最も最近追加
    [C]
    [B]
    [A] ← 最初に追加
     ⬇️ エントリー

タイムライン: [1秒/ティック]
呼び出し:      ⬇️  ⬇️  ⬇️     ⬇️
キュー:       [ABC]   [AB]    [A]    []
処理済み:    C       B       A
```

スタック動作は以下に特に有用:
- 最も最近のアクションを最初に元に戻す必要がある元に戻す/やり直すシステム
- 最も最近のページに戻りたいブラウザ履歴ナビゲーション
- プログラミング言語実装での関数呼び出しスタック
- 深さ優先探索アルゴリズム

```ts
const stack = new Queuer<number>({
  addItemsTo: 'back', // デフォルト
  getItemsFrom: 'back', // スタック動作のためデフォルトをオーバーライド
})
stack.addItem(1) // [1]
stack.addItem(2) // [1, 2]
// アイテムは順番に処理: 2, 次に1

stack.getNextItem('back') // キューの前面ではなく背面から次のアイテムを取得
```

#### 優先度キュー

優先度キューは、挿入順ではなく優先度に基づいてアイテムをソートすることで、キュー順序付けに別の次元を追加します。各アイテムには優先度値が割り当てられ、キューは自動的にアイテムを優先度順に維持します。

```text
優先度キューの可視化:

エントリー →  [P:5][P:3][P:2][P:1] → エグジット
              ⬇️           ⬆️
         高優先度アイテム   低優先度アイテム
         ここに           最後に処理

タイムライン: [1秒/ティック]
呼び出し:      ⬇️(P:2)  ⬇️(P:5)  ⬇️(P:1)     ⬇️(P:3)
キュー:       [2]      [5,2]    [5,2,1]    [3,2,1]    [2,1]    [1]    []
処理済み:              5         -          3         2        1
```

優先度キューは以下に不可欠:
- 一部のタスクが他より緊急なタスクスケジューラ
- 特定の種類のトラフィックが優先処理を必要とするネットワークパケットルーティング
- 高優先度イベントが低優先度イベントより先に処理される必要があるイベントシステム
- 一部のリクエストが他より重要なリソース割り当て

```ts
const priorityQueue = new Queuer<number>({
  getPriority: (n) => n // 数値が大きいほど優先度が高い
})
priorityQueue.addItem(1) // [1]
priorityQueue.addItem(3) // [3, 1]
priorityQueue.addItem(2) // [3, 2, 1]
// 処理順: 3, 2, 次に1
```

### 開始と停止

`Queuer`クラスは`start()`と`stop()`メソッドを通じて処理の開始と停止をサポートし、`started`オプションで自動開始を設定できます:

```ts
const queue = new Queuer<number>({ 
  wait: 1000,
  started: false // 一時停止状態で開始
})

// 処理を制御
queue.start() // アイテム処理を開始
queue.stop()  // 処理を一時停止

// 処理状態を確認
console.log(queue.getIsRunning()) // キューが現在処理中かどうか
console.log(queue.getIsIdle())    // キューが実行中だが空かどうか
```

フレームワークアダプターを使用していてキューオプションがリアクティブな場合、`started`オプションを条件付き値に設定できます:

```ts
const queue = useQueuer(
  processItem, 
  { 
    wait: 1000,
    started: isOnline // 接続状態に基づいて開始/停止（リアクティブオプションをサポートするフレームワークアダプターを使用している場合）
  }
)
```

### 追加機能

Queuerはキュー管理のためのいくつかの便利なメソッドを提供します:

```ts
// キュー検査
queue.getPeek()           // 削除せずに次のアイテムを表示
queue.getSize()          // 現在のキューサイズを取得
queue.getIsEmpty()       // キューが空かどうかを確認
queue.getIsFull()        // キューがmaxSizeに達したかどうかを確認
queue.getAllItems()   // キュー内のすべてのアイテムのコピーを取得

// キュー操作
queue.clear()         // すべてのアイテムを削除
queue.reset()         // 初期状態にリセット
queue.getExecutionCount() // 処理されたアイテム数を取得

// イベント処理
queue.onItemsChange((item) => {
  console.log('処理済み:', item)
})
```

### 拒否処理

キューが最大サイズ（`maxSize`オプションで設定）に達すると、新しいアイテムは拒否されます。Queuerはこれらの拒否を処理および監視する方法を提供します:

```ts
const queue = new Queuer<number>({
  maxSize: 2, // キュー内のアイテムを2つまでに制限
  onReject: (item, queuer) => {
    console.log('キューがいっぱいです。アイテムが拒否されました:', item)
  }
})

queue.addItem(1) // 受理
queue.addItem(2) // 受理
queue.addItem(3) // 拒否、onRejectコールバックがトリガー

console.log(queue.getRejectionCount()) // 1
```

### 初期アイテム

作成時にキューを初期アイテムで事前に設定できます:

```ts
const queue = new Queuer<number>({
  initialItems: [1, 2, 3],
  started: true // 即時処理を開始
})

// キューは[1, 2, 3]で開始し、すぐに処理を開始
```

### 動的設定

Queuerのオプションは、作成後に`setOptions()`で変更し、`getOptions()`で取得できます:

```ts
const queue = new Queuer<number>({
  wait: 1000,
  started: false
})

// 設定を変更
queue.setOptions({
  wait: 500, // アイテムを2倍の速さで処理
  started: true // 処理を開始
})

// 現在の設定を取得
const options = queue.getOptions()
console.log(options.wait) // 500
```

### パフォーマンス監視

Queuerはパフォーマンスを監視するメソッドを提供します:

```ts
const queue = new Queuer<number>()

// アイテムを追加して処理
queue.addItem(1)
queue.addItem(2)
queue.addItem(3)

console.log(queue.getExecutionCount()) // 処理されたアイテム数
console.log(queue.getRejectionCount()) // 拒否されたアイテム数
```

### 非同期キューイング

複数のワーカーによる非同期操作を処理するには、`AsyncQueuer`クラスをカバーする[非同期キューイングガイド](../guides/async-queueing)を参照してください。

### フレームワークアダプター

各フレームワークアダプターは、キューアークラスの周りに便利なフックや関数を構築します。`useQueuer`や`useQueueState`のようなフックは、一般的な使用例で必要な定型コードを減らすことができる小さなラッパーです。
