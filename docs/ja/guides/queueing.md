---
source-updated-at: '2025-05-05T07:34:55.000Z'
translation-updated-at: '2025-05-06T23:09:25.940Z'
title: キューイングガイド
id: queueing
---
以下は日本語訳です：

[レートリミット](../guides/rate-limiting)、[スロットリング](../guides/throttling)、[デバウンス](../guides/debouncing)のように頻繁に発生する実行をドロップするのとは異なり、キューイングはすべての操作が処理されることを保証するように設定できます。リクエストを失うことなく操作の流れを管理・制御する方法を提供します。これにより、データ損失が許容されないシナリオに最適です。また、キューイングには最大サイズを設定することもでき、メモリリークやその他の問題を防ぐのに役立ちます。このガイドでは、TanStack Pacerのキューイング概念について説明します。

## キューイングの概念

キューイングは、処理が追いつかないほど速く操作が到着しても、すべての操作が最終的に処理されることを保証します。他の実行制御技術が過剰な操作をドロップするのに対し、キューイングは操作を順序付きリストにバッファリングし、特定のルールに従って処理します。これにより、`maxSize`が指定されてバッファが満杯の場合にアイテムが拒否されない限り、TanStack Pacerで唯一の「ロスレス」な実行制御技術となります。

### キューイングの可視化

```text
キューイング（2ティックごとに1アイテムを処理）
タイムライン: [1ティック=1秒]
呼び出し:     ⬇️  ⬇️  ⬇️     ⬇️  ⬇️     ⬇️  ⬇️  ⬇️
キュー:      [ABC]   [BC]    [BCDE]    [DE]    [E]    []
実行済み:     ✅     ✅       ✅        ✅      ✅     ✅
             [=================================================================]
             ^ レートリミット/スロットリング/デバウンスとは異なり、
               すべての呼び出しが順番に最終的に処理される

             [アイテムがキューに溜まる]   [1つずつ着実に処理]   [キューが空になる]
              ビジー時                   順番に処理            空の状態
```

### キューイングを使用するタイミング

キューイングは、即時実行よりもデータの一貫性と完全性が重要な場合、すべての操作が処理されることを保証する必要がある場合に特に重要です。`maxSize`を使用すると、保留中の操作が多すぎてシステムが圧迫されるのを防ぐバッファとしても機能します。

一般的な使用例：
- システムに過負荷をかけずに必要なデータを事前に取得
- すべてのアクションを記録する必要があるUIでのユーザー操作の処理
- データの一貫性を維持する必要があるデータベース操作の処理
- すべてが正常に完了する必要があるAPIリクエストの処理
- ドロップできないバックグラウンドタスクの調整
- すべてのフレームが重要なアニメーションシーケンス
- すべてのエントリを保存する必要があるフォーム送信
- `maxSize`を使用した固定容量のデータストリームのバッファリング

### キューイングを使用しないタイミング

以下の場合、キューイングは最適な選択ではないかもしれません：
- すべての操作を処理するよりも即時のフィードバックが重要な場合
- 最新の値のみが重要な場合（代わりに[デバウンス](../guides/debouncing)を使用）

> [!TIP]
> 現在レートリミット、スロットリング、またはデバウンスを使用していて、操作がドロップされることで問題が発生している場合、キューイングが求めている解決策である可能性が高いです。

## TanStack Pacerでのキューイング

TanStack Pacerは、シンプルな`queue`関数とより強力な`Queuer`クラスを通じてキューイングを提供します。他の実行制御技術が通常関数ベースのAPIを重視するのに対し、キューイングはクラスベースのAPIが提供する追加の制御から恩恵を受けることがよくあります。

### `queue`を使った基本的な使用法

`queue`関数は、アイテムが追加されるとすぐに処理される常に実行中のキューを作成する簡単な方法を提供します：

```ts
import { queue } from '@tanstack/pacer'

// 1秒ごとにアイテムを処理するキューを作成
const processItems = queue<number>({
  wait: 1000,
  maxSize: 10, // オプション：メモリや時間の問題を防ぐためにキューサイズを制限
  onItemsChange: (queuer) => {
    console.log('現在のキュー:', queuer.getAllItems())
  }
})

// 処理するアイテムを追加
processItems(1) // 即時処理
processItems(2) // 1秒後に処理
processItems(3) // 2秒後に処理
```

`queue`関数は使いやすいですが、`addItem`メソッドを通じて基本的な常時実行キューしか提供しません。ほとんどの使用例では、`Queuer`クラスが提供する追加の制御と機能が必要になるでしょう。

### `Queuer`クラスを使った高度な使用法

`Queuer`クラスは、キューの動作と処理を完全に制御します：

```ts
import { Queuer } from '@tanstack/pacer'

// 1秒ごとにアイテムを処理するキューを作成
const queue = new Queuer<number>({
  wait: 1000, // アイテム間の処理待機時間1秒
  maxSize: 5, // オプション：メモリや時間の問題を防ぐためにキューサイズを制限
  onItemsChange: (queuer) => {
    console.log('現在のキュー:', queuer.getAllItems())
  }
})

// 処理を開始
queue.start()

// 処理するアイテムを追加
queue.addItem(1)
queue.addItem(2)
queue.addItem(3)

// アイテムは1つずつ、各間に1秒の遅延で処理される
// 出力:
// Processing: 1 (即時)
// Processing: 2 (1秒後)
// Processing: 3 (2秒後)
```

### キューの種類と順序付け

TanStack PacerのQueuerの特徴は、位置ベースのAPIを通じてさまざまな使用例に適応できることです。同じQueuerが、一貫したインターフェースを通じて、従来のキュー、スタック、または両端キューとして動作できます。

#### FIFOキュー（先入れ先出し）

アイテムが追加された順に処理されるデフォルトの動作です。最も一般的なキュータイプで、最初に追加されたアイテムが最初に処理されるという原則に従います。`maxSize`を使用すると、キューが満杯の場合に新しいアイテムは拒否されます。

```text
FIFOキューの可視化（maxSize=3の場合）:

エントリー →  [A][B][C] → エグジット
             ⬇️     ⬆️
          新しいアイテム   アイテムは
          ここに追加     ここで処理される
          （満杯なら拒否）

タイムライン: [1ティック=1秒]
呼び出し:     ⬇️  ⬇️  ⬇️     ⬇️  ⬇️
キュー:      [ABC]   [BC]    [C]    []
処理済み:    A       B       C
拒否:       D      E
```

FIFOキューは以下に最適：
- 順序が重要なタスク処理
- メッセージを順番に処理する必要があるメッセージキュー
- 送信された順に印刷する必要がある印刷キュー
- イベントを時系列で処理する必要があるイベント処理システム

```ts
const queue = new Queuer<number>({
  addItemsTo: 'back', // デフォルト
  getItemsFrom: 'front', // デフォルト
})
queue.addItem(1) // [1]
queue.addItem(2) // [1, 2]
// 処理順: 1、次に2
```

#### LIFOスタック（後入れ先出し）

アイテムの追加と取得の両方に「back」を位置として指定することで、キューはスタックとして動作します。スタックでは、最も最近追加されたアイテムが最初に処理されます。`maxSize`を使用すると、スタックが満杯の場合に新しいアイテムは拒否されます。

```text
LIFOスタックの可視化（maxSize=3の場合）:

     ⬆️ 処理
    [C] ← 最も最近追加
    [B]
    [A] ← 最初に追加
     ⬇️ エントリー
     （満杯なら拒否）

タイムライン: [1ティック=1秒]
呼び出し:     ⬇️  ⬇️  ⬇️     ⬇️  ⬇️
キュー:      [ABC]   [AB]    [A]    []
処理済み:    C       B       A
拒否:       D      E
```

スタック動作は以下に特に有用：
- 最も最近のアクションを最初に元に戻す必要がある元に戻す/やり直すシステム
- 最も最近のページに戻りたいブラウザの履歴ナビゲーション
- プログラミング言語実装での関数呼び出しスタック
- 深さ優先探索アルゴリズム

```ts
const stack = new Queuer<number>({
  addItemsTo: 'back', // デフォルト
  getItemsFrom: 'back', // スタック動作のためにデフォルトを上書き
})
stack.addItem(1) // [1]
stack.addItem(2) // [1, 2]
// アイテムは順番に処理: 2、次に1

stack.getNextItem('back') // キューの前部ではなく後部から次のアイテムを取得
```

#### 優先度キュー

優先度キューは、各アイテムに優先度値を割り当て、キューが自動的にアイテムを優先度順に維持することで、順序付けに別の次元を追加します。`maxSize`を使用すると、キューが満杯の場合、優先度の低いアイテムは拒否される可能性があります。

```text
優先度キューの可視化（maxSize=3の場合）:

エントリー →  [P:5][P:3][P:2] → エグジット
              ⬇️           ⬆️
         高優先度アイテム   低優先度アイテム
         ここに配置        最後に処理
         （満杯なら拒否）

タイムライン: [1ティック=1秒]
呼び出し:     ⬇️(P:2)  ⬇️(P:5)  ⬇️(P:1)     ⬇️(P:3)
キュー:      [2]      [5,2]    [5,2,1]    [3,2,1]    [2,1]    [1]    []
処理済み:              5         -          3         2        1
拒否:                         4
```

優先度キューは以下に不可欠：
- 一部のタスクが他よりも緊急を要するタスクスケジューラ
- 特定の種類のトラフィックが優先的に扱われる必要があるネットワークパケットルーティング
- 高優先度のイベントが低優先度のイベントより先に処理される必要があるイベントシステム
- 一部のリクエストが他よりも重要なリソース割り当て

```ts
const priorityQueue = new Queuer<number>({
  getPriority: (n) => n // 数値が大きいほど優先度が高い
})
priorityQueue.addItem(1) // [1]
priorityQueue.addItem(3) // [3, 1]
priorityQueue.addItem(2) // [3, 2, 1]
// 処理順: 3、2、次に1
```

### 開始と停止

`Queuer`クラスは、`start()`および`stop()`メソッドを通じて処理の開始と停止をサポートし、`started`オプションで自動的に開始するように設定できます：

```ts
const queue = new Queuer<number>({ 
  wait: 1000,
  started: false // 一時停止状態で開始
})

// 処理を制御
queue.start() // アイテムの処理を開始
queue.stop()  // 処理を一時停止

// 処理状態を確認
console.log(queue.getIsRunning()) // キューが現在処理中かどうか
console.log(queue.getIsIdle())    // キューが実行中だが空かどうか
```

キューのオプションがリアクティブなフレームワークアダプターを使用している場合、`started`オプションを条件付きの値に設定できます：

```ts
const queue = useQueuer(
  processItem, 
  { 
    wait: 1000,
    started: isOnline // 接続状態に基づいて開始/停止（リアクティブオプションをサポートするフレームワークアダプターを使用している場合）
  }
)
```

### 追加機能

Queuerはキューの管理に役立ついくつかのメソッドを提供します：

```ts
// キュー検査
queue.getPeek()           // 削除せずに次のアイテムを表示
queue.getSize()          // 現在のキューサイズを取得
queue.getIsEmpty()       // キューが空かどうかを確認
queue.getIsFull()        // キューがmaxSizeに達しているかどうかを確認
queue.getAllItems()   // キューに入っているすべてのアイテムのコピーを取得

// キューの操作
queue.clear()         // すべてのアイテムを削除
queue.reset()         // 初期状態にリセット
queue.getExecutionCount() // 処理されたアイテムの数を取得

// イベント処理
queue.onItemsChange((item) => {
  console.log('処理済み:', item)
})
```

### アイテムの有効期限

Queuerは、キュー内に長時間留まったアイテムの自動期限切れをサポートしています。これは、古いデータが処理されるのを防いだり、キューに入れられた操作にタイムアウトを実装したりするのに役立ちます。

```ts
const queue = new Queuer<number>({
  expirationDuration: 5000, // アイテムは5秒後に期限切れ
  onExpire: (item, queuer) => {
    console.log('アイテムが期限切れ:', item)
  }
})

// またはカスタムの期限切れチェックを使用
const queue = new Queuer<number>({
  getIsExpired: (item, addedAt) => {
    // カスタムの期限切れロジック
    return Date.now() - addedAt > 5000
  },
  onExpire: (item, queuer) => {
    console.log('アイテムが期限切れ:', item)
  }
})

// 期限切れの統計を確認
console.log(queue.getExpirationCount()) // 期限切れになったアイテムの数
```

有効期限機能は以下に特に有用：
- 古いデータが処理されるのを防ぐ
- キューに入れられた操作にタイムアウトを実装
- 古いアイテムを自動的に削除してメモリ使用量を管理
- 限られた時間のみ有効な一時データの処理

### 拒否処理

キューが最大サイズ（`maxSize`オプションで設定）に達すると、新しいアイテムは拒否されます。Queuerはこれらの拒否を処理および監視する方法を提供します：

```ts
const queue = new Queuer<number>({
  maxSize: 2, // キューには2アイテムのみ許可
  onReject: (item, queuer) => {
    console.log('キューが満杯です。アイテムが拒否されました:', item)
  }
})

queue.addItem(1) // 受理
queue.addItem(2) // 受理
queue.addItem(3) // 拒否、onRejectコールバックがトリガーされる

console.log(queue.getRejectionCount()) // 1
```

### 初期アイテム

キューを作成時に初期アイテムで事前に埋めることができます：

```ts
const queue = new Queuer<number>({
  initialItems: [1, 2, 3],
  started: true // 即時処理を開始
})

// キューは[1, 2, 3]で開始し、処理を開始
```

### 動的設定

Queuerのオプションは、`setOptions()`を使用して作成後に変更でき、`getOptions()`を使用して取得できます：

```ts
const queue = new Queuer<number>({
  wait: 1000,
  started: false
})

// 設定を変更
queue.setOptions({
  wait: 500, // アイテムを2倍の速さで処理
  started: true // 処理を開始
})

// 現在の設定を取得
const options = queue.getOptions()
console.log(options.wait) // 500
```

### パフォーマンス監視

Queuer
